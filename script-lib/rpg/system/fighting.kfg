
[[doctype spellcast/book]]
[[locales locales/*]]

[system rpg:fighting]

	# We have to gosub to that scene, not call to a fn, because we need a fresh scope
	[scene fight]
		[add-to-panel]
			-	label: $> Primary/ability
				image: /icons/primary.svg
				id: primary
			-	label: $> Wield/unwield
				image: /icons/catch.svg
				id: wield
		
		# It would be nice to have true constants support in KFG
		[set $const]
			# Multiplier
			offensiveness-bonus: 1.15
			offensiveness-malus: 0.8
			
			# Exponential base, should multiply 40/20 times to go down to 0.5
			low-pressure: 0.983
			pressure: 0.966
			
			anti-aiming-base: 5
			anti-aiming-factor: 1
			
			initiative-roll:
				critical-factor: 2
				critical-chance: 0.05
			
			melee-attack-roll:
				over-power: 2.5
			
			ranged-aiming-roll:
				over-power: 1.5
			
			ranged-attack-roll:
				over-power: 3
			
			wrestling-attack-roll:
				over-power: 3
		
		[set $fight]
			foes: <Array>
			allies: <Array>
			turns: <Array>
			true-distance: $= $args.distance is-set? ( abs $args.distance ) 0
		
		[set $fight.distance] $= round $fight.true-distance 2
		
		[create-scheduler $fight.scheduler]

		[foreach $args.foes => $local.index : $local.foe]
			[if ! ( $local.foe is-entity? )]
				[create-entity $local.foe] $local.foe
			[set $fight.foes[$local.index]] $local.foe
			[append $fight.turns] $local.foe
			[set $local.foe.adhoc.fight]
				side: foes
				offensiveness: $= $local.foe.stances.offensiveness is-set? $local.foe.stances.offensiveness 0
				press-target: null
				pressure: 0
				speed: 0
				goneThrough: 0
				alertness: $= 100 / $local.foe.actual.stats.fighting
			[add-to-scheduler $fight.scheduler]
				performer: $local.foe
				ready-time: $local.foe.adhoc.fight.alertness

		[foreach $args.allies => $local.index : $local.ally]
			[if ! ( $local.ally is-entity? )]
				[create-entity $local.ally] $local.ally
			[set $fight.allies[$local.index]] $local.ally
			[append $fight.turns] $local.ally
			[set $local.ally.adhoc.fight]
				side: allies
				offensiveness: $= $local.ally.stances.offensiveness is-set? $local.ally.stances.offensiveness 0
				press-target: null
				pressure: 0
				speed: 0
				goneThrough: 0
				alertness: $= 100 / $local.ally.actual.stats.fighting
			[add-to-scheduler $fight.scheduler]
				performer: $local.ally
				ready-time: $local.ally.adhoc.fight.alertness

		#[debug info] $fight.allies
		#[debug info] $fight.foes
		#[debug info] $fight.alive-foes
		#[debug info] $fight.turns

		[set $fight.deadly-push] $args.deadly-push

		[if $fight.distance = 0]
			[message] $> ^yThe opponents are already in melee!
		[else]
			[message] $> ^yThe distance between opponents is ${fight.distance} ${fight.distance}[n?step|steps].
		
		[set $fight.last-displayed-distance] $fight.distance

		[call scheduler-loop]



	[fn scheduler-loop]
		[set $fight.time] 0
		[set $fight.round] 0
		
		[on $fight.scheduler elapsed]
			[add $fight.time] $args
			#[message] $> elapsed: ${args} -- time: ${fight.time}
			[call manage-distance] $args
			[call battle-lines]

		[on $fight.scheduler empty]
			#[message] $> ^Mempty event!
			[set $fight.ended] true
		
		[on $fight.scheduler ready]
			#[message] $> ready: ${args.performer.name}
			
			[if $args.performer.status.health <= 0]
				[call manage-death] $args.performer
				[return]
			[elseif $fight.ending]
				[remove-from-scheduler $fight.scheduler] $args.performer
				[return]
			
			[set $fight.performer] $args.performer
			
			[if $args.performer.npc]
				[call npc-turn]
			[else]
				[gosub pc-turn]
		
		# Not useful, it kicks in immediately after	ready
		#[on $fight.scheduler started]
		#	[message] $> started: ${args.performer.name} ${args.action}
		
		[on $fight.scheduler prepared]
			[if $args.performer.status.health <= 0]
				[call manage-death] $args.performer
				[return]
			
			#[message] $> prepared: ${args.performer.name} ${args.action}
			[set $local.fn] $= $args.action .. "-prepared"
			[call $local.fn] $args.action-data
		
			[set $args.performer.adhoc.fight.goneThrough] 0
			
		[on $fight.scheduler released]
			#[message] $> released: ${args.performer.name} ${args.action} ${args.action-data.performer}
			#[if $args.performer.status.health <= 0]
			[if $args.performer.adhoc.fight.goneThrough]
				[message]
					text: $> ^W^+At the same time: 
					continue: true
			[set $local.fn] $= $args.action .. "-released"
			[call $local.fn] $args.action-data
			
			# It is called AFTER anything else, the "releasing" state is unbreakable
			#[message] $> after release: ${args.performer.status.health}
			[if $args.performer.status.health <= 0]
				[call manage-death] $args.performer
		
		[on $fight.scheduler recovered]
			#[message] $> recovered: ${args.performer.name} ${args.action} ${args.action-data.performer}
			[if $args.performer.status.health <= 0]
				[call manage-death] $args.performer
			[elseif $fight.ending]
				[remove-from-scheduler $fight.scheduler] $args.performer
			#[message] $> recovered: ${args.performer.name} ${args.action}
			#[set $local.fn] $= $args.action .. "-recovered"
			#[call $local.fn] $args.action-data
		
		[loop]
			#[message] $> ^RLoop
			[filter $fight.foes => $fight.alive-foes] $= $this.status.alive
			[filter $fight.allies => $fight.alive-allies] $= $this.status.alive

			[if $fight.ended]
				[if ! $fight.alive-allies.length]
					[call lost]
					[return]
				[elseif ! $fight.alive-foes.length]
					[call win]
					[return]
				[else]
					# Hmmm, what should be done here?
					[call win]
					[return]
			[elseif ( ! $fight.alive-allies.length ) || ( ! $fight.alive-foes.length )]
				[set $fight.ending] true
			
			[advance-scheduler $fight.scheduler 10]
			#[pause 1]
			#[message] After pause



	[fn manage-distance]
		# Manage distance
		[if $fight.distance > 0]
			[map $fight.alive-allies => $local.allies-speed] $this.adhoc.fight.speed
			[map $fight.alive-foes => $local.foes-speed] $this.adhoc.fight.speed

			[set $local.time-factor] $= $args / 20
			[set $local.speed] $= ( avg( ... $local.allies-speed ) ) + ( avg( ... $local.foes-speed ) )
			
			[set $fight.true-distance] $= max( 0 , ( $fight.true-distance - ( $local.speed * $local.time-factor ) ) )
			[set $local.distance] $= round $fight.true-distance 2
			
			[if $local.distance != $fight.distance]
				[set $fight.distance] $local.distance
				[if ! ( $fight.last-displayed-distance %= $fight.distance 1.5)]
					[if $fight.distance = 0]
						[message] $> ^yThe two opposing crews join together and clash.
					[else]
						[message] $> ^yThe remaining distance between opponents is ${fight.distance} ${fight.distance}[n?step|steps].
					
					[set $fight.last-displayed-distance] $fight.distance



	[fn win]
		[message] $> ${fight.allies[0].name//uc1} win the fight.
		[set $local.xp-reward] 0

		[foreach $fight.foes => $local.entity]
			[add $local.xp-reward] $local.entity.params.xp-reward

		[set $local.xp-reward] $= ceil( $local.xp-reward / $fight.allies.length )

		[foreach $fight.allies => $local.index : $local.entity]
			[add $local.entity.status.xp] $local.xp-reward

		[message] $> You gain ${local.xp-reward} xp (=${fight.allies[0].status.xp}).

		[gosub loot]
			# Temp:
			performer: $fight.allies[0]
			targets: $fight.foes



	[fn lost]
		[message] $> ${fight.allies[0].name//uc1} died on the battlefield.
		[lost]



	[fn all-pressure]
		[foreach $fight.alive-entities => $local.entity]
			[call pressure] $local.entity

	[fn pressure]
		[reduce $fight.alive-entities , 0 => $args.adhoc.fight.pressure]
			$= $this.previous + ( ( $this.current.adhoc.fight.press-target = $args ) ? $this.current.adhoc.fight.press-value 0 )
		# Pressure has a max level, because when the target is "saturated",
		# extra opponents are not able to reach the target properly:
		# both the target and its opponents get some malus, therefore the pressure is capped to 18 (4 charging opponents)
		[set $args.adhoc.fight.pressure] $= min( max( 0 , $args.adhoc.fight.pressure - 6 ) , 18 )



	[fn battle-lines]
		[filter $fight.alive-foes => $front] $= $this.adhoc.fight.offensiveness > 0
		[filter $fight.alive-foes => $middle] $= $this.adhoc.fight.offensiveness = 0
		[filter $fight.alive-foes => $back] $= $this.adhoc.fight.offensiveness < 0

		[set $offset] $= ceil( ( 1 - $front.length ) / 2 )
		[foreach $front => $index : $entity]
			[set $entity.adhoc.fight.position]
				x: $= $fight.distance / 2
				y: $= $index + $offset

		[set $offset] $= ceil( ( 1 - $middle.length ) / 2 )
		[foreach $middle => $index : $entity]
			[set $entity.adhoc.fight.position]
				x: $= ( $fight.distance / 2 ) + 1
				y: $= $index + $offset

		[set $offset] $= ceil( ( 1 - $back.length ) / 2 )
		[foreach $back => $index : $entity]
			[set $entity.adhoc.fight.position]
				x: $= ( $fight.distance / 2 ) + 2
				y: $= $index + $offset

		[sort $fight.alive-foes]
			$= ( $this.left.adhoc.fight.position.y + ( $this.left.adhoc.fight.position.x / 1000 ) )
			$= - ( $this.right.adhoc.fight.position.y + ( $this.right.adhoc.fight.position.x / 1000 ) )

		# Same for allies

		[filter $fight.alive-allies => $front] $= $this.adhoc.fight.offensiveness > 0
		[filter $fight.alive-allies => $middle] $= $this.adhoc.fight.offensiveness = 0
		[filter $fight.alive-allies => $back] $= $this.adhoc.fight.offensiveness < 0

		[set $offset] $= ceil( ( 1 - $front.length ) / 2 )
		[foreach $front => $index : $entity]
			[set $entity.adhoc.fight.position]
				x: $= - ( $fight.distance / 2 )
				y: $= $index + $offset

		[set $offset] $= ceil( ( 1 - $middle.length ) / 2 )
		[foreach $middle => $index : $entity]
			[set $entity.adhoc.fight.position]
				x: $= ( - ( $fight.distance / 2 ) ) - 1
				y: $= $index + $offset

		[set $offset] $= ceil( ( 1 - $back.length ) / 2 )
		[foreach $back => $index : $entity]
			[set $entity.adhoc.fight.position]
				x: $= ( - ( $fight.distance / 2 ) ) - 2
				y: $= $index + $offset

		[sort $fight.alive-allies]
			$= ( $this.left.adhoc.fight.position.y + ( $this.left.adhoc.fight.position.x / 1000 ) )
			$= - ( $this.right.adhoc.fight.position.y + ( $this.right.adhoc.fight.position.x / 1000 ) )
		[set $fight.alive-entities] $= concat $fight.alive-foes $fight.alive-allies



	[fn npc-turn]
		[call npc-targeting]
		#[call npc-targeting => $local.target]

		[set $performer] $fight.performer

		[if $performer.params.battle-cry && ( ( random ) <= $performer.params.battle-cry )]
			[if $performer.params.battle-cry-flavor]
				[set $local.battle-cry] $= random-element $performer.params.battle-cry-flavor
				[apply $local.battle-cry => $local.flavor] $
				[message] $local.flavor
			[else]
				[message] $> ${performer.name//uc1} shouts!


		[if $performer.params.charge && ( ( random ) <= $performer.params.charge )]
			[call charge]
				performer: $performer
				target: $fight.target
			
			[return]

		[call melee-fighting]
			performer: $performer
			target: $fight.target

		[return]



	[fn npc-targeting]
		[set $local.possible-targets] <Array>

		[if ( $fight.performer.adhoc.fight.side = "allies" ) xor ( $args.target-allies )]
			[concat $local.possible-targets] $fight.alive-foes

		[if ( $fight.performer.adhoc.fight.side = "foes" ) xor ( $args.target-allies )]
			[concat $local.possible-targets] $fight.alive-allies

		[set $local.index] $= random( $local.possible-targets.length - 1 )
		
		# Which one?
		[set $fight.target] $local.possible-targets[$local.index]
		#[return] $local.possible-targets[$local.index]



	[scene pc-turn]
		[next-style] table
		
		[if $fight.distance = 0]
			[set $local.item] $fight.performer.primary.melee-fighting

			[if $local.item.usages.melee-fighting.primary.params.menu-label]
				[set $local.label] $local.item.usages.melee-fighting.primary.params.menu-label
			[else]
				[set $local.label] $> fight

			[next pc-melee-fighting]
				[label] $> ${local.label//uc1}
				[on-trigger]
					[set $fight.performer.adhoc.fight.offensiveness] 0

			[next pc-melee-fighting]
				[label] $> ${local.label//uc1} boldly
				[on-trigger]
					[set $fight.performer.adhoc.fight.offensiveness] 1

			[next pc-melee-fighting]
				[label] $> ${local.label//uc1} cautiously
				[on-trigger]
					[set $fight.performer.adhoc.fight.offensiveness] -1
		[else]
			[next pc-melee-fighting]
				[label] $> March
				[on-trigger]
					[set $fight.performer.adhoc.fight.offensiveness] 0

			[next pc-melee-fighting]
				[label] $> March boldly
				[on-trigger]
					[set $fight.performer.adhoc.fight.offensiveness] 1

			[next pc-melee-fighting]
				[label] $> March cautiously
				[on-trigger]
					[set $fight.performer.adhoc.fight.offensiveness] -1

		[next-group-break]
		
		[next pc-charge] $> Charge!

		[if $fight.performer.primary.ranged-fighting]
			[set $local.item] $fight.performer.primary.ranged-fighting

			[if $local.item.usages.ranged-fighting.primary.params.menu-label]
				[set $local.label] $local.item.usages.ranged-fighting.primary.params.menu-label
			[else]
				[set $local.label] $> Shoot

			[next pc-ranged-fighting] $> ${local.label//uc1}

		[if $fight.performer.primary.battle-ability]
			[set $local.item] $fight.performer.primary.battle-ability

			[if $local.item.usages.battle-ability.primary.params.menu-label]
				[set $local.label] $local.item.usages.battle-ability.primary.params.menu-label
			[else]
				[set $local.label] $> Use ability

			[next pc-battle-ability] $> ${local.label//uc1}

		[next-group-break]
		
		[next pc-turn]
			[label] $> Primary/ability
			[button] primary
			[on-trigger]
				[gosub rpg:inventory/ability-menu]
					[alt]
					[args]
						performer: $fight.performer

		[next pc-turn]
			[label] $> Wield/unwield
			[button] wield
			[on-trigger]
				[gosub rpg:inventory/equip-object-slot-menu => $local.changed]
					[alt]
					[args]
						performer: $fight.performer
						slot: hand
						scheduler: $fight.scheduler
				[if $local.changed]
					[set $fight.performer.adhoc.fight.speed] 0
					[set $fight.performer.adhoc.fight.offensiveness] -1
					[set $fight.performer.adhoc.fight.press-target] null
					[set $fight.performer.adhoc.fight.press-value] 0
					[return]



	[scene pc-targeting]
		[set $local.count] 0

		[set $local.possible-targets] <Array>

		[if ( $fight.performer.adhoc.fight.side = "allies" ) xor ( $args.target-allies )]
			[concat $local.possible-targets] $fight.alive-foes

		[if ( $fight.performer.adhoc.fight.side = "foes" ) xor ( $args.target-allies )]
			[concat $local.possible-targets] $fight.alive-allies

		[if $local.possible-targets.length <= 1]
			[set $fight.target] $local.possible-targets[0]
			[return]

		[message] $> Target?

		[foreach $local.possible-targets => $local.index : $local.entity]
			[if $local.entity.adhoc.fight.offensiveness > 0]
				[set $local.position] "←"
			[elseif $local.entity.adhoc.fight.offensiveness < 0]
				[set $local.position] "→    "
			[else]
				[set $local.position] "   "

			[next]
				[args]
					index: $local.index
				[label] $> ${local.position} ${local.entity.name//uc1}
				[on-trigger]
					[set $fight.target] $local.possible-targets[$args.index]



	[scene pc-melee-fighting]
		[if $fight.distance = 0]
			[gosub pc-targeting]
				[alt]
		[call melee-fighting]
			performer: $fight.performer
			target: $fight.target
		[return]



	[scene pc-charge]
		[if $fight.distance = 0]
			[gosub pc-targeting]
				[alt]
		[call charge]
			performer: $fight.performer
			target: $fight.target
		[return]



	[scene pc-ranged-fighting]
		[gosub pc-targeting]
			[alt]
		[call ranged-fighting]
			performer: $fight.performer
			target: $fight.target
		[return]



	[scene pc-battle-ability]
		[call battle-ability]
			performer: $fight.performer
		[return]



	[fn melee-fighting]
		[set $performer] $args.performer
		[set $target] $args.target
	
		[set $performer.adhoc.fight.speed] $= $performer.actual.stats.quickness * ( $performer.adhoc.fight.offensiveness ??? 0.3 0.6 0.9 )

		[if $fight.distance > 0]
			[set $performer.adhoc.fight.press-target] null
			[set $performer.adhoc.fight.press-value] 0

			[if $performer.adhoc.fight.offensiveness > 0]
				[message] $> ${performer.name//uc1} runs toward the opposing crew.
			[elseif $performer.adhoc.fight.offensiveness < 0]
				[message] $> ${performer.name//uc1} walks cautiously toward the opposing crew.
			[else]
				[message] $> ${performer.name//uc1} marches toward the opposing crew.

		#[message] $> ready time: ${performer.adhoc.fight.alertness}
		#[message] $> prepare time: ${performer.actual-usages.melee-fighting.compound.prepare-time}
		#[message] $> release time: ${performer.actual-usages.melee-fighting.compound.release-time}
		#[message] $> recover time: ${performer.actual-usages.melee-fighting.compound.recover-time}
		
		[schedule-action $fight.scheduler]
			performer: $performer
			action: melee-fighting
			action-data:
				performer: $performer
				target: $target
			ready-time: $performer.adhoc.fight.alertness
			prepare-time: $= $performer.actual-usages.melee-fighting.compound.prepare-time
			release-time: $= $performer.actual-usages.melee-fighting.compound.release-time
			recover-time: $= $performer.actual-usages.melee-fighting.compound.recover-time
		
	
	
	[fn melee-fighting-prepared]
		[set $performer] $args.performer
		[set $target] $args.target
		[set $item] $performer.primary.melee-fighting
	
		# Still out of reach
		[if $fight.distance > 0]
			[return]
	
	
	[fn melee-fighting-released]
		[set $performer] $args.performer
		[set $target] $args.target
		[set $item] $performer.primary.melee-fighting
		
		# Still out of reach
		[if $fight.distance > 0]
			[return]
		
		[set $performer.adhoc.fight.press-target] $target
		[set $performer.adhoc.fight.press-value] $= $performer.adhoc.fight.offensiveness ??? 3 4 6

		[call pressure] $performer
		[call pressure] $target

		[if $performer.actual-usages.melee-fighting.params.spell-level is-set?]
			[call rpg:spellcasting/cast => $local.casted]
				performer: $performer
				item: $item
				usage: $performer.actual-usages.melee-fighting
				bonus-factor: $= $const.low-pressure ^ $performer.adhoc.fight.pressure
			[if ! $local.casted]
				[return]

		[set $local.attack-score] $performer.actual-usages.melee-fighting.compound.attack
		[set $local.defense-score] $target.actual-usages.melee-fighting.compound.defense

		#[message] $> Pressure -- ${performer.adhoc.fight.pressure} / ${target.adhoc.fight.pressure}
		#[message] $> A: ${local.attack-score} vs ${local.defense-score}

		[if $performer.adhoc.fight.offensiveness > 0]
			[mul $local.attack-score] $const.offensiveness-bonus
			# Less sensible to the pressure when attacking
			[mul $local.attack-score] $= $const.low-pressure ^ $performer.adhoc.fight.pressure
		[elseif $performer.adhoc.fight.offensiveness < 0]
			[mul $local.attack-score] $const.offensiveness-malus
			[mul $local.attack-score] $= $const.pressure ^ $performer.adhoc.fight.pressure
		[else]
			[mul $local.attack-score] $= $const.pressure ^ $performer.adhoc.fight.pressure

		[if $target.adhoc.fight.offensiveness > 0]
			[mul $local.defense-score] $const.offensiveness-malus
			[mul $local.defense-score] $= $const.pressure ^ $target.adhoc.fight.pressure
		[elseif $target.adhoc.fight.offensiveness < 0]
			[mul $local.defense-score] $const.offensiveness-bonus
			# Less sensible to the pressure when defending
			[mul $local.defense-score] $= $const.low-pressure ^ $target.adhoc.fight.pressure
		[else]
			[mul $local.defense-score] $= $const.pressure ^ $target.adhoc.fight.pressure

		#[message] $> Melee: ${local.attack-score} vs ${local.defense-score}
		
		[inc $target.adhoc.fight.goneThrough]
		
		[if success-roll( $local.attack-score , $local.defense-score , ... $const.melee-attack-roll )]
			[call deal-damages]

			[call effects]
				performer: $performer
				target: $target
				position: $target.adhoc.fight.position
				actual-usage: $performer.actual-usages.ranged-fighting

		[else]
			[fortune]
				- $> ${performer.name//uc1} misses ${target.name}.
				- $> ${target.name//uc1} blocks ${performer.name}.
				- $> ${target.name//uc1} avoids ${performer.name}.



	[fn charge]
		[set $performer] $args.performer
		[set $target] $args.target
	
		[set $performer.adhoc.fight.speed] $performer.actual.stats.quickness
		[set $performer.adhoc.fight.offensiveness] 1

		[if $fight.distance > 0]
			[set $performer.adhoc.fight.press-target] null
			[set $performer.adhoc.fight.press-value] 0
			[message] $> ${performer.name//uc1} charges toward the opposing crew.
		
		[schedule-action $fight.scheduler]
			performer: $performer
			action: charge
			action-data:
				performer: $performer
				target: $target
			ready-time: $performer.adhoc.fight.alertness
			prepare-time: $performer.actual-usages.melee-fighting.compound.prepare-time
			release-time: $performer.actual-usages.melee-fighting.compound.release-time
			recover-time: $performer.actual-usages.melee-fighting.compound.recover-time
		
	
	
	[fn charge-prepared]
		[set $performer] $args.performer
		[set $target] $args.target

	
	
	[fn charge-released]
		[set $performer] $args.performer
		[set $target] $args.target

		# Still out of reach
		[if $fight.distance > 0]
			[return]

		[set $local.attack-score] $performer.actual-usages.melee-fighting.compound.attack
		[set $local.defense-score] $target.actual-usages.melee-fighting.compound.defense

		[set $performer.adhoc.fight.press-target] $target
		[set $performer.adhoc.fight.press-value] 6

		[call pressure] $performer
		[call pressure] $target

		#[message] $> Pressure -- ${performer.adhoc.fight.pressure} / ${target.adhoc.fight.pressure}
		#[message] $> A: ${local.attack-score} vs ${local.defense-score}

		# A charge is always offensive!
		[mul $local.attack-score] $const.offensiveness-bonus
		# Charge is less sensible to the pressure
		[mul $local.attack-score] $= $const.low-pressure ^ $performer.adhoc.fight.pressure

		[if $target.adhoc.fight.offensiveness > 0]
			[mul $local.defense-score] $const.offensiveness-malus
			[mul $local.defense-score] $= $const.pressure ^ $target.adhoc.fight.pressure
		[elseif $target.adhoc.fight.offensiveness < 0]
			[mul $local.defense-score] $const.offensiveness-bonus
			# Less sensible to the pressure when defending
			[mul $local.defense-score] $= $const.low-pressure ^ $target.adhoc.fight.pressure
		[else]
			[mul $local.defense-score] $= $const.pressure ^ $target.adhoc.fight.pressure

		#[message] $> Charge: ${local.attack-score} vs ${local.defense-score}

		[message] $> ${performer.name//uc1} charges ${target.name}!

		[inc $target.adhoc.fight.goneThrough]
		
		[if success-roll( $local.attack-score , $local.defense-score , ... $const.melee-attack-roll )]
			[call deal-damages]

			[if $fight.deadly-push]
				[call deadly-push]
		[else]
			[fortune]
				- $> ${performer.name//uc1} misses ${target.name}.
				- $> ${target.name//uc1} blocks ${performer.name}.
				- $> ${target.name//uc1} avoids ${performer.name}.



	[fn ranged-fighting]
		[set $performer] $args.performer
		[set $target] $args.target
		
		[set $performer.adhoc.fight.speed] 0
		[set $performer.adhoc.fight.offensiveness] -1
		
		[schedule-action $fight.scheduler]
			performer: $performer
			action: ranged-fighting
			action-data:
				performer: $performer
				target: $target
			ready-time: $performer.adhoc.fight.alertness
			prepare-time: $= $performer.actual-usages.ranged-fighting.compound.prepare-time
			release-time: $= $performer.actual-usages.ranged-fighting.compound.release-time
			recover-time: $= $performer.actual-usages.ranged-fighting.compound.recover-time
	
	
	
	[fn ranged-fighting-prepared]
		[set $performer] $args.performer
		[set $target] $args.target
		[set $item] $performer.primary.ranged-fighting
	
	
	
	[fn ranged-fighting-released]
		[set $performer] $args.performer
		[set $target] $args.target
		[set $item] $performer.primary.ranged-fighting

		[if $item.usages.ranged-fighting.primary.params.projectile-name]
			[set $projectile.name] $item.usages.ranged-fighting.primary.params.projectile-name
		[else]
			[set $projectile] $item

		#[debug info] $projectile
		#[debug info] $item.usages.ranged-fighting.primary.params.projectile-name

		[set $performer.adhoc.fight.press-target] $target
		[set $performer.adhoc.fight.press-value] 4

		[call pressure] $performer
		[call pressure] $target

		[if $performer.actual-usages.ranged-fighting.params.spell-level is-set?]
			[call rpg:spellcasting/cast => $local.casted]
				performer: $performer
				item: $item
				usage: $performer.actual-usages.ranged-fighting
				bonus-factor: $= $const.low-pressure ^ $performer.adhoc.fight.pressure
			[if ! $local.casted]
				[return]

		[inc $target.adhoc.fight.goneThrough]
		
		# We are in close range, we have to test first with the closeRange stat,
		# against the anti-ranged stat
		[if $fight.distance = 0]
			
			[set $local.attack-score] $performer.actual-usages.ranged-fighting.compound.close-ranged
			[set $local.defense-score] $target.actual-usages.melee-fighting.compound.anti-ranged

			#[message] $> Close range A: ${local.attack-score} vs ${local.defense-score}
			#[message] $> Pressure: ${performer.adhoc.fight.pressure}

			[mul $local.attack-score] $= $const.pressure ^ $performer.adhoc.fight.pressure

			[if $target.adhoc.fight.offensiveness > 0]
				[mul $local.defense-score] $const.offensiveness-malus
				[mul $local.defense-score] $= $const.pressure ^ $target.adhoc.fight.pressure
			[elseif $target.adhoc.fight.offensiveness < 0]
				[mul $local.defense-score] $const.offensiveness-bonus
				# Less sensible to the pressure when defending
				[mul $local.defense-score] $= $const.low-pressure ^ $target.adhoc.fight.pressure
			[else]
				[mul $local.defense-score] $= $const.pressure ^ $target.adhoc.fight.pressure

			#[message] $> Close range: ${local.attack-score} vs ${local.defense-score}

			[if ! ( success-roll( $local.attack-score , $local.defense-score , ... $const.melee-attack-roll ) )]
				[message] $> ${target.name//uc1} prevents ${performer.name} from attacking from afar.
				[return]

		[set $local.aiming-score] $performer.actual-usages.ranged-fighting.compound.aiming
		[set $local.anti-aiming-score] $= $const.anti-aiming-base + ( $const.anti-aiming-factor * ( $fight.distance + ( ( abs $target.adhoc.fight.speed ) / 2 ) ) )
		
		#[message] $> Aiming A: ${local.aiming-score} vs ${local.guard-score}
		#[message] $> Pressure: ${performer.adhoc.fight.pressure}

		[mul $local.aiming-score] $= $const.pressure ^ $performer.adhoc.fight.pressure
		
		[set $local.guard-score] $target.actual-usages.ranged-fighting.compound.guard
		
		# We use a correlated-success-rolls to avoid decreasing the chance to hit by performing two uncorrelated rolls
		[set $local.aiming] $= correlated-success-rolls( $local.aiming-score , [ $local.anti-aiming-score , $local.guard-score ] , ... $const.ranged-aiming-roll )
		#[message] $> Aiming: ${local.aiming-score} vs ${local.anti-aiming-score} / ${local.guard-score} => ${local.aiming[0]} / ${local.aiming[1]}
		
		[if ! $local.aiming[0]]
			[message] $> ${performer.name//uc1} misses ${target.name}.
			[return]

		[if ! $local.aiming[1]]
			[if $target.actual-usages.ranged-fighting.params.guard-flavor is-set?]
				[apply $target.actual-usages.ranged-fighting.params.guard-flavor => $local.flavor] $
				[message] $local.flavor
			[else]
				[message] $> ${performer.name//uc1} misses ${target.name}.
			[return]

		[set $local.attack-score] $performer.actual-usages.ranged-fighting.compound.attack
		[set $local.defense-score] $target.actual-usages.ranged-fighting.compound.defense

		# /!\ FIXME?
		[add $local.defense-score] $= $fight.distance / 5

		#[message] $> Pressure -- ${performer.adhoc.fight.pressure} / ${target.adhoc.fight.pressure}
		#[message] $> Ranged: ${local.attack-score} vs ${local.defense-score}

		# Attack score of ranged-fighting do not depend much on the character but on the weapon

		[if $target.adhoc.fight.offensiveness > 0]
			[mul $local.defense-score] $const.offensiveness-malus
			[mul $local.defense-score] $= $const.pressure ^ $target.adhoc.fight.pressure
		[elseif $target.adhoc.fight.offensiveness < 0]
			[mul $local.defense-score] $const.offensiveness-bonus
			# Less sensible to the pressure when defending
			[mul $local.defense-score] $= $const.low-pressure ^ $target.adhoc.fight.pressure
		[else]
			[mul $local.defense-score] $= $const.pressure ^ $target.adhoc.fight.pressure

		#[message] $> B: ${local.attack-score} vs ${local.defense-score}

		[if success-roll( $local.attack-score , $local.defense-score , ... $const.ranged-attack-roll )]
			[call deal-damages]
				usage: $performer.actual-usages.ranged-fighting

			[call effects]
				performer: $performer
				target: $target
				position: $target.adhoc.fight.position
				usage: $performer.actual-usages.ranged-fighting

		[else]
			[fortune]
				- $> ${target.name//uc1} blocks ${performer.name}'s ${projectile.name}.
				- $> ${target.name//uc1} avoids ${performer.name}'s ${projectile.name}.



	[fn battle-ability]
		[set $performer] $args.performer
		[set $target] $performer
		[set $local.usage] $performer.actual-usages.battle-ability
		[set $item] $performer.primary.battle-ability

		[if $local.usage.params.targeting]
			[if $performer.npc]
				[call npc-targeting]
					target-allies: $local.usage.params.target-allies
			[else]
				[gosub pc-targeting]
					[alt]
					[args]
						target-allies: $local.usage.params.target-allies
			[set $target] $fight.target

		# Check if the ability has its own speed and offensiveness value
		[if $item.params.speed is-number?]
			[set $performer.adhoc.fight.speed] $item.params.speed
		[if $item.params.offensiveness is-number?]
			[set $performer.adhoc.fight.offensiveness] $item.params.offensiveness

		[schedule-action $fight.scheduler]
			performer: $performer
			action: battle-ability
			action-data:
				performer: $performer
				target: $target
				position: $local.position
			ready-time: $performer.adhoc.fight.alertness
			prepare-time: $performer.actual-usages.battle-ability.compound.prepare-time
			release-time: $performer.actual-usages.battle-ability.compound.release-time
			recover-time: $performer.actual-usages.battle-ability.compound.recover-time

	
	
	[fn battle-ability-prepared]
		[set $performer] $args.performer
		[set $target] $args.target
		[set $local.usage] $performer.actual-usages.battle-ability
		[set $item] $performer.primary.battle-ability
	
	
	
	[fn battle-ability-released]
		[set $performer] $args.performer
		[set $target] $args.target
		[set $local.usage] $performer.actual-usages.battle-ability
		[set $item] $performer.primary.battle-ability

		# Position MUST be set on release time
		[set $local.position] $target.adhoc.fight.position
		
		[call pressure] $performer

		[if $local.usage.params.spell-level is-set?]
			[call rpg:spellcasting/cast => $local.casted]
				performer: $performer
				item: $item
				usage: $local.usage
				bonus-factor: $= $const.low-pressure ^ $performer.adhoc.fight.pressure
			[if ! $local.casted]
				[return]

		[if $target != $performer]
			[inc $target.adhoc.fight.goneThrough]
		
		[call effects]
			performer: $performer
			target: $target
			position: $local.position
			usage: $local.usage



	[fn equip-prepared] <TagContainer>
	
	[fn equip-released]
		[call rpg:inventory/equip-object] $args
	
	[fn unequip-prepared] <TagContainer>
	
	[fn unequip-released]
		[call rpg:inventory/unequip-object] $args
	
	
	
	[fn deal-damages]
		[if $args.target]
			[set $target] $args.target

		[if ! $args.usage]
			[set $args.usage] $performer.actual-usages.melee-fighting

		#[message] $> Critical factor: ${args.usage.compound.critical-factor}
		
		# Damage level
		[if $args.damages is-real?]
			[set $local.attack-score] $args.damages
		[else]
			[set $local.attack-score] $args.usage.compound.damages
			
			[if $args.usage.compound.offensiveness-damage-mod]
				# Attacker offensiveness is used only when not using fixed damage base
				[if $performer.adhoc.fight.offensiveness > 0]
					[mul $local.attack-score] $const.offensiveness-bonus
				[elseif $performer.adhoc.fight.offensiveness < 0]
					[mul $local.attack-score] $const.offensiveness-malus

		[if $args.bonus-factor is-real?]
			[mul $local.attack-score] $args.bonus-factor

		[set $local.defense-score] $target.actual.stats.resilience

		[if $args.usage.compound.offensiveness-damage-mod]
			[if $target.adhoc.fight.offensiveness > 0]
				[mul $local.defense-score] $const.offensiveness-malus
			[elseif $target.adhoc.fight.offensiveness < 0]
				[mul $local.defense-score] $const.offensiveness-bonus

		#[message] $> Damages: ${local.attack-score} vs ${local.defense-score}

		[set $damages]
			$= quantity-roll( $local.attack-score , $local.defense-score ,
			$=   base: 15 ,
			$=   over-power: 2 ,
			$=   critical-factor: $args.usage.compound.critical-factor ,
			$=   critical-chance: 0.05 ,
			$=   lower-divide: false ,
			$=   round: true
			$= )

		#[message] $> damages: ${damages}

		[sub $target.status.health] $damages

		[call rpg:common/update-malus] $target

		[if $damages >= 100]
			[if $args.fatal-hit-flavor is-set?]
				[apply $args.fatal-hit-flavor => $local.flavor] $
			[elseif $args.critical-hit-flavor is-set?]
				[apply $args.critical-hit-flavor => $local.flavor] $
			[elseif $args.hit-flavor is-set?]
				[apply $args.hit-flavor => $local.flavor] $
			[elseif $args.usage.params.fatal-hit-flavor is-set?]
				[apply $args.usage.params.fatal-hit-flavor => $local.flavor] $
			[elseif $args.usage.params.critical-hit-flavor is-set?]
				[apply $args.usage.params.critical-hit-flavor => $local.flavor] $
			[elseif $args.usage.params.hit-flavor is-set?]
				[apply $args.usage.params.hit-flavor => $local.flavor] $
			[else]
				[set $local.flavor] $> ^r${performer.name//uc1} deadly hits ${target.name} for ${damages} hp.
		[elseif $damages >= 25]
			[if $args.critical-hit-flavor is-set?]
				[apply $args.critical-hit-flavor => $local.flavor] $
			[elseif $args.hit-flavor is-set?]
				[apply $args.hit-flavor => $local.flavor] $
			[elseif $args.usage.params.critical-hit-flavor is-set?]
				[apply $args.usage.params.critical-hit-flavor => $local.flavor] $
			[elseif $args.usage.params.hit-flavor is-set?]
				[apply $args.usage.params.hit-flavor => $local.flavor] $
			[else]
				[set $local.flavor] $> ^r${performer.name//uc1} critically hits ${target.name} for ${damages} hp.
		[else]
			[if $args.hit-flavor is-set?]
				[apply $args.hit-flavor => $local.flavor] $
			[elseif $args.usage.params.hit-flavor is-set?]
				[apply $args.usage.params.hit-flavor => $local.flavor] $
			[else]
				[set $local.flavor] $> ^r${performer.name//uc1} hits ${target.name} for ${damages} hp.

		[message] $local.flavor



	[fn manage-death]
		[set $performer] $args
		#[message] $> manage death! ${performer.name} ${performer.status.health} ${performer.status.alive}
		[if ( $performer.status.health > 0 ) || ( ! $performer.status.alive )]
			[return]
		
		[set $performer.status.alive] false
		[message] $> ^R^+${performer.name//uc1} is dead.
		[remove-from-scheduler $fight.scheduler] $performer
	
	
	
	[fn heal-damages]
		[if $args.target]
			[set $target] $args.target

		[if ! $args.usage]
			[set $args.usage] $performer.actual-usages.battle-ability

		#[message] $> ^Khealing -- checking: ${target.name}

		#[if $target.status.health >= 100]
		#	[return]

		# Healing score
		[if $args.healing is-real?]
			[set $local.healing-score] $args.healing
		[else]
			[set $local.healing-score] $args.usage.compound.healing

		[set $local.defense-score] $target.actual.stats.resilience

		[if $args.bonus-factor is-real?]
			[mul $healing-score] $args.bonus-factor
		
		[set $healing]
			$= quantity-roll( $local.healing-score , $local.defense-score ,
			$=   base: 10 ,
			$=   over-power: 1 ,
			$=   critical-factor: $args.usage.compound.critical-factor ,
			$=   critical-chance: 0.05 ,
			$=   lower-divide: true ,
			$=   round: true
			$= )
		
		#[message] $> ^Khealing: ${healing}

		# Cap the healing
		[set $healing] $= min( $healing , 100 - $target.status.health )

		[add $target.status.health] $healing

		[call rpg:common/update-malus] $target

		[if $args.flavor is-set?]
			[apply $args.flavor => $local.flavor] $
		[elseif $args.usage.params.flavor is-set?]
			[apply $args.usage.params.flavor => $local.flavor] $
		[else]
			[set $local.flavor] $> ^r${performer.name//uc1} heals ${target.name} for ${healing} hp.

		[message] $local.flavor



	[fn effects]
		[if $args.usage.params.effects is-empty?]
			[return]

		[foreach $args.usage.params.effects => $local.effect]

			[set $local.exclude] <Array>

			[if $local.effect.filter.exclude-self]
				[append $local.exclude] $args.performer

			[if $local.effect.filter.exclude-target]
				[append $local.exclude] $args.target

			[if $local.effect.filter.type = "radius"]
				[call radius-filter => $local.entities]
					exclude: $local.exclude
					position: $args.position
					radius: $local.effect.filter.radius
			[else]
				[set $local.entities]
					- $args.target

			# If the effect has modifiers, apply them now
			[if $local.effect.mods]
				[merge $args.usage.compound , $local.effect.mods => $local.effect-compound]
			[else]
				[set $local.effect-compound] $args.usage.compound

			[if $local.effect.type = "attack"]
				[call attack-effect]
					performer: $args.performer
					entities: $local.entities
					attack: $local.effect-compound.attack
					damages: $local.effect-compound.damages
					defense-type: $local.effect.defense-type
					miss-flavor: $local.effect.miss-flavor
					hit-flavor: $local.effect.hit-flavor
					critical-hit-flavor: $local.effect.critical-hit-flavor
					fatal-hit-flavor: $local.effect.fatal-hit-flavor
			[elseif $local.effect.type = "healing"]
				[call healing-effect]
					performer: $args.performer
					entities: $local.entities
					healing: $local.effect-compound.healing
					flavor: $local.effect.flavor



	[fn radius-filter]
		#[debug info] $args

		[set $local.entities] <Array>

		[foreach $fight.alive-entities => $local.target]

			[if $args.exclude has $local.target]
				[continue]

			# Clone it, it can be modified
			[clone $local.target-pos] $local.target.adhoc.fight.position
			#[set $local.target-pos] $local.target.adhoc.fight.position

			# If the target is currently attacking/pressing the current position and is not defensive,
			# act as if its y twice as close as the spash y position, because of encirclement
			[set $local.press-pos] $local.target.adhoc.fight.press-target.adhoc.fight.position

			[if $local.press-pos && ( $local.target.adhoc.fight.offensiveness >= 0 ) && ( $local.press-pos.x = $args.position.x ) && ( $local.press-pos.y = $args.position.y )]
				# Divide the delta-y by 2
				[set $local.target-pos.y] $= avg( $local.target-pos.y , $args.position.y )

			[set $local.distance] $= hypot( $local.target-pos.x - $args.position.x , $local.target-pos.y - $args.position.y )

			[if $local.distance <= $args.radius]
				[append $local.entities] $local.target

		[return] $local.entities



	[fn attack-effect]
		[if $args.usage-type is-empty?]
			[set $args.defense-type] ranged-fighting

		[foreach $args.entities => $target]
			[set $local.attack-score] $args.attack
			[set $local.defense-score] $target.actual-usages[$args.defense-type].compound.defense

			[call pressure] $target

			[if $target.adhoc.fight.offensiveness > 0]
				[mul $local.defense-score] $const.offensiveness-malus
				[mul $local.defense-score] $= $const.pressure ^ $target.adhoc.fight.pressure
			[elseif $target.adhoc.fight.offensiveness < 0]
				[mul $local.defense-score] $const.offensiveness-bonus
				# Less sensible to the pressure when defending
				[mul $local.defense-score] $= $const.low-pressure ^ $target.adhoc.fight.pressure
			[else]
				[mul $local.defense-score] $= $const.pressure ^ $target.adhoc.fight.pressure
			
			#[message] $> Attack-effect: ${local.attack-score} vs ${local.defense-score}
			
			[if $target != $args.performer]
				[inc $target.adhoc.fight.goneThrough]
			
			[if success-roll( $local.attack-score , $local.defense-score , ... $const.melee-attack-roll )]
				[call deal-damages]
					target: $target
					hit-flavor: $args.hit-flavor
					critical-hit-flavor: $args.critical-hit-flavor
					fatal-hit-flavor: $args.fatal-hit-flavor
					damages: $args.damages

			[else]
				[if $args.miss-flavor]
					[apply $args.miss-flavor => $local.flavor] $
					[message] $local.flavor



	[fn healing-effect]
		[foreach $args.entities => $target]
			[if $target != $args.performer]
				[inc $target.adhoc.fight.goneThrough]
			
			[call heal-damages]
				target: $target
				flavor: $args.flavor
				healing: $args.healing



	[fn deadly-push]
		[set $local.attack-score]
			$= ( max( $performer.actual.stats.strength , $performer.actual.stats.fighting - 3 ) )
			$= * $fight.deadly-push.bonus-factor
		[set $local.defense-score] $= $target.actual.stats.strength
		
		[mul $local.attack-score] $= $const.low-pressure ^ $performer.adhoc.fight.pressure
		[mul $local.defense-score] $= $const.low-pressure ^ $target.adhoc.fight.pressure

		#[message] $> Attacker ${performer.name} offensiveness: ${performer.adhoc.fight.offensiveness}
		[if $performer.adhoc.fight.offensiveness > 0]
			[mul $local.attack-score] $const.offensiveness-bonus
		[elseif $performer.adhoc.fight.offensiveness < 0]
			[mul $local.attack-score] $const.offensiveness-malus

		#[message] $> Defender ${target.name} offensiveness: ${target.adhoc.fight.offensiveness}
		[if $target.adhoc.fight.offensiveness > 0]
			[mul $local.defense-score] $const.offensiveness-malus
		[elseif $target.adhoc.fight.offensiveness < 0]
			[mul $local.defense-score] $const.offensiveness-bonus

		[if success-roll( $local.attack-score , $local.defense-score , ... $const.wrestling-attack-roll )]
			[if $target.status.health > 0]
				[set $target.status.health] 0
			[apply $fight.deadly-push.flavor => $local.flavor] $
			[message] $local.flavor



	[scene loot]
		[message] $> Loot?
		[next]
			[label] $> Yes
			[on-trigger]
				[call drop => $local.stack] $args
				[gosub rpg:inventory/drop-grab]
					[alt]
					[args]
						performer: $args.performer
						stack: $local.stack
		[next] $> No



	[fn drop]
		[set $local.stack] <Array>

		[foreach $args.targets => $local.entity]
			[drop $local.entity]
				all: true
				unequip: true
				into: $local.stack

		[return] $local.stack
