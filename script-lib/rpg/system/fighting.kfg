
[[doctype adventurer]]
[[locales locales/*]]

[system fighting]
	
	[scene fight]
		
		[set $fight] <Object>
		
		[set $fight.foes] <Array>
		[set $fight.allies] <Array>
		[set $fight.turns] <Array>
		[set $fight.distance] $= ( $args.distance is-set? ) ? ( floor ( abs $args.distance ) 2 ) 0
		
		[foreach $args.foes => $local.index : $local.foe]
			[if ! ( $local.foe is-entity? )]
				[create-entity $local.foe] $local.foe
			[set $fight.foes[$local.index]] $local.foe
			[append $fight.turns] $local.foe
			[set $local.foe.adhoc.fight]
				side: foes
				cooldown: 0
				offensiveness: $= ( $local.foe.stances.offensiveness is-set? ) ? $local.foe.stances.offensiveness 0
				pressTarget: null
				pressure: 0
				speed: 0
			
		[foreach $args.allies => $local.index : $local.ally]
			[if ! ( $local.ally is-entity? )]
				[create-entity $local.ally] $local.ally
			[set $fight.allies[$local.index]] $local.ally
			[append $fight.turns] $local.ally
			[set $local.ally.adhoc.fight]
				side: allies
				cooldown: 0
				offensiveness: $= ( $local.ally.stances.offensiveness is-set? ) ? $local.ally.stances.offensiveness 0
				pressTarget: null
				pressure: 0
				speed: 0
			
		#[debug info] $fight.allies
		#[debug info] $fight.foes
		#[debug info] $fight.aliveFoes
		#[debug info] $fight.turns
		
		[set $fight.deadlyPush] $args.deadlyPush
		
		[call initiative]
		#[next initiative]
		#[goto new-turn]
		
		[call fight-loop]
	
	
	
	[fn initiative]
		[foreach $fight.turns => $local.entity]
			[set $local.entity.adhoc.fight.initiativeScore] $= $local.entity.actual.stats.fighting + ( 2 D 8 )
		
			[if $local.entity.adhoc.fight.offensiveness > 0]
				[add $local.entity.adhoc.fight.initiativeScore] 2
			[elseif $local.entity.adhoc.fight.offensiveness < 0]
				[sub $local.entity.adhoc.fight.initiativeScore] 3
		
		#[sort $fight.turns] $= - $this.adhoc.fight.initiativeScore
		[sort $fight.turns] $= $this.right.adhoc.fight.initiativeScore - $this.left.adhoc.fight.initiativeScore
		
		#[debug info] $fight.turns
		[message] $> ^yThe distance between opponents is ${fight.distance} ${fight.distance}[n?step|steps].
		[message] $> ${fight.turns[0].label//uc1} takes the initiative.
		#[goto new-turn]
		
	
	
	[fn fight-loop]
		
		[set $fight.turnCount] 0
		[set $fight.turnIndex] 0
		[set $fight.round] 0
		
		[while true]
			
			# Former scene end-turn:
			
			[if $fight.turnCount]
				[set $fight.turnIndex] $= ( $fight.turnIndex + 1 ) % $fight.turns.length
				
				[if $fight.turnIndex = 0]
					[call next-round]
			
			[inc $fight.turnCount]
			
			[filter $fight.foes => $fight.aliveFoes] $= $this.status.hp > 0
			[filter $fight.allies => $fight.aliveAllies] $= $this.status.hp > 0
			
			[if ! $fight.aliveAllies.length]
				[goto lost]
			[elseif ! $fight.aliveFoes.length]
				[goto win]
			
			
			# Former scene new-turn:
			
			[set $fight.entityTurn] $= $fight.turns[$fight.turnIndex]
			
			[if $fight.entityTurn.status.hp <= 0]
				[continue]
			
			[if $fight.entityTurn.adhoc.fight.cooldown > 0]
				[dec $fight.entityTurn.adhoc.fight.cooldown]
				[continue]
			
			[call battle-lines]
			
			[if $fight.entityTurn.npc]
				[call npc-turn]
			[else]
				[gosub pc-turn]
			
			
			
	[fn next-round]
		[inc $fight.round]
		
		# Manage distance
		[if $fight.distance > 0]
			[map $fight.aliveAllies => $local.alliesSpeed] $this.adhoc.fight.speed
			[map $fight.aliveFoes => $local.foesSpeed] $this.adhoc.fight.speed
			
			[set $fight.distance] $= max 0 ( trunc ( $fight.distance - ( avg $local.alliesSpeed ) - ( avg $local.foesSpeed ) ) 2 )
			
			[if $fight.distance = 0]
				[message] $> ^yThe two opposing crews join together and clash.
			[else]
				[message] $> ^yThe remaining distance between opponents is ${fight.distance} ${fight.distance}[n?step|steps].
		
	
	
	[scene win]
		[message] $> ${fight.allies[0].label//uc1} win the fight.
		[set $local.xpReward] 0
		
		[foreach $fight.foes => $local.entity]
			[add $local.xpReward] $local.entity.params.xpReward
		
		[set $local.xpReward] $= ceil ( $local.xpReward / $fight.allies.length )
		
		[foreach $fight.allies => $local.index : $local.entity]
			[add $local.entity.status.xp] $local.xpReward
		
		[message] $> You gain ${local.xpReward} xp (=${fight.allies[0].status.xp}).
	
	
	
	[scene lost]
		[message] $> ${fight.allies[0].label//uc1} died on the battlefield.
		[lost]
	
	
	
	[fn all-pressure]
		[foreach $fight.aliveEntities => $local.entity]
			[call pressure] $local.entity
		
	[fn pressure]
		[reduce $fight.aliveEntities , 0 => $args.adhoc.fight.pressure] $= $this.previous + ( ( $this.current.adhoc.fight.pressTarget = $args ) ? $this.current.adhoc.fight.pressValue 0 )
		# Pressure has a max level, because when the target is saturated,
		# extra opponents are not able to reach the target properly:
		# both the target and its opponents get some malus, therefore the pressure is capped to 18 (4 charging opponents)
		[set $args.adhoc.fight.pressure] $= min ( max 0 ( $args.adhoc.fight.pressure - 6 ) ) 18
		
		
		
	[fn battle-lines]
		
		[filter $fight.aliveFoes => $front] $= $this.adhoc.fight.offensiveness > 0
		[filter $fight.aliveFoes => $middle] $= $this.adhoc.fight.offensiveness = 0
		[filter $fight.aliveFoes => $back] $= $this.adhoc.fight.offensiveness < 0
		
		[set $offset] $= ceil ( ( 1 - $front.length ) / 2 )
		[foreach $front => $index : $entity]
			[set $entity.adhoc.fight.position]
				x: $= $fight.distance / 2
				y: $= $index + $offset
		
		[set $offset] $= ceil ( ( 1 - $middle.length ) / 2 )
		[foreach $middle => $index : $entity]
			[set $entity.adhoc.fight.position]
				x: $= ( $fight.distance / 2 ) + 1
				y: $= $index + $offset
		
		[set $offset] $= ceil ( ( 1 - $back.length ) / 2 )
		[foreach $back => $index : $entity]
			[set $entity.adhoc.fight.position]
				x: $= ( $fight.distance / 2 ) + 2
				y: $= $index + $offset
		
		#[sort $fight.aliveFoes] $= $this.adhoc.fight.position.y + ( $this.adhoc.fight.position.x / 1000 )
		[sort $fight.aliveFoes] $= ( $this.left.adhoc.fight.position.y + ( $this.left.adhoc.fight.position.x / 1000 ) ) - ( $this.right.adhoc.fight.position.y + ( $this.right.adhoc.fight.position.x / 1000 ) )
		
		#[map $fight.aliveFoes => $tmp] $this.adhoc.fight
		#[debug info] $tmp
		
		# Same for allies
		
		[filter $fight.aliveAllies => $front] $= $this.adhoc.fight.offensiveness > 0
		[filter $fight.aliveAllies => $middle] $= $this.adhoc.fight.offensiveness = 0
		[filter $fight.aliveAllies => $back] $= $this.adhoc.fight.offensiveness < 0
		
		[set $offset] $= ceil ( ( 1 - $front.length ) / 2 )
		[foreach $front => $index : $entity]
			[set $entity.adhoc.fight.position]
				x: $= - ( $fight.distance / 2 )
				y: $= $index + $offset
		
		[set $offset] $= ceil ( ( 1 - $middle.length ) / 2 )
		[foreach $middle => $index : $entity]
			[set $entity.adhoc.fight.position]
				x: $= ( - ( $fight.distance / 2 ) ) - 1
				y: $= $index + $offset
		
		[set $offset] $= ceil ( ( 1 - $back.length ) / 2 )
		[foreach $back => $index : $entity]
			[set $entity.adhoc.fight.position]
				x: $= ( - ( $fight.distance / 2 ) ) - 2
				y: $= $index + $offset
			
		#[sort $fight.aliveAllies] $= $this.adhoc.fight.position.y + ( $this.adhoc.fight.position.x / 1000 )
		[sort $fight.aliveAllies] $= ( $this.left.adhoc.fight.position.y + ( $this.left.adhoc.fight.position.x / 1000 ) ) - ( $this.right.adhoc.fight.position.y + ( $this.right.adhoc.fight.position.x / 1000 ) )
		[set $fight.aliveEntities] $= concat $fight.aliveFoes $fight.aliveAllies
		
		
	
	[fn npc-turn]
		
		[call npc-targeting]
		
		[set $performer] $fight.entityTurn
		
		[if $performer.params.battleCry && ( ( random ) <= $performer.params.battleCry )]
			[if $performer.params.battleCryFlavour]
				[apply-to $local.flavour] $= random-element $performer.params.battleCryFlavour
				[message] $local.flavour
			[else]
				[message] $> ${performer.label//uc1} shouts!
		
		
		[if $performer.params.charge && ( ( random ) <= $performer.params.charge )]
			[call charge]
				performer: $performer
				target: $fight.target
			[return]
		
		[call melee-fighting]
			performer: $performer
			target: $fight.target
		
		[return]
		
	
	
	[fn npc-targeting]
		
		[if $fight.entityTurn.adhoc.fight.side = "allies"]
			[set $local.enemies] $fight.aliveFoes
		[else]
			[set $local.enemies] $fight.aliveAllies
		
		[set $local.index] $= random ( $local.enemies.length - 1 )
		[set $fight.target] $local.enemies[$local.index]
	
	
	
	[scene pc-turn]
		[if $fight.distance = 0]
			[set $local.item] $fight.entityTurn.primary.melee-fighting
			
			[if $local.item.usages.melee-fighting.primary.params.menuLabel]
				[set $local.label] $local.item.usages.melee-fighting.primary.params.menuLabel
			[else]
				[set $local.label] $> fight
			
			[next pc-melee-fighting]
				[label] $> ${local.label//uc1}
				[on-trigger]
					[set $fight.entityTurn.adhoc.fight.offensiveness] 0
			
			[next pc-melee-fighting]
				[label] $> ${local.label//uc1} boldly
				[on-trigger]
					[set $fight.entityTurn.adhoc.fight.offensiveness] 1
			
			[next pc-melee-fighting]
				[label] $> ${local.label//uc1} cautiously
				[on-trigger]
					[set $fight.entityTurn.adhoc.fight.offensiveness] -1
		[else]
			[next pc-melee-fighting]
				[label] $> March
				[on-trigger]
					[set $fight.entityTurn.adhoc.fight.offensiveness] 0
			
			[next pc-melee-fighting]
				[label] $> March boldly
				[on-trigger]
					[set $fight.entityTurn.adhoc.fight.offensiveness] 1
			
			[next pc-melee-fighting]
				[label] $> March cautiously
				[on-trigger]
					[set $fight.entityTurn.adhoc.fight.offensiveness] -1
		
		[next pc-charge]
			[label] Charge!
	
		#[if ( $fight.distance > 0 ) && ( $fight.entityTurn.primary.ranged-fighting )]
		[if $fight.entityTurn.primary.ranged-fighting]
			[set $local.item] $fight.entityTurn.primary.ranged-fighting
			
			[if $local.item.usages.ranged-fighting.primary.params.menuLabel]
				[set $local.label] $local.item.usages.ranged-fighting.primary.params.menuLabel
			[else]
				[set $local.label] $> Shoot
			
			[next pc-ranged-fighting]
				[label] $> ${local.label//uc1}
		
		#[next inventory/equip-ability]
		#	[label] Choose an ability
	
		[next pc-turn]
			[label] Select primary ability or object
			[on-trigger]
				[gosub inventory/select-ability-choose-primary]
					[args]
						performer: $fight.entityTurn
	
		[next pc-turn]
			[label] Equip object in hand
			[on-trigger]
				[gosub inventory/equip-object => $local.changed]
					[args]
						performer: $fight.entityTurn
						slot: hand
				[if $local.changed]
					[set $fight.entityTurn.adhoc.fight.speed] 0
					[set $fight.entityTurn.adhoc.fight.offensiveness] -1
					[set $fight.entityTurn.adhoc.fight.pressTarget] null
					[set $fight.entityTurn.adhoc.fight.pressValue] 0
					[return]
	
	
	
	[scene pc-targeting]
		[set $local.count] 0
		
		[if $fight.entityTurn.adhoc.fight.side = "allies"]
			[set $local.enemies] $fight.aliveFoes
		[else]
			[set $local.enemies] $fight.aliveAllies
		
		[if $local.enemies.length <= 1]
			[set $fight.target] $local.enemies[0]
			[return]
		
		[message] Target?
		
		[foreach $local.enemies => $local.index : $local.entity]
			[if $local.entity.adhoc.fight.offensiveness > 0]
				[set $local.position] "←"
			[elseif $local.entity.adhoc.fight.offensiveness < 0]
				[set $local.position] "→    "
			[else]
				[set $local.position] "   "
			
			[next]
				[args]
					index: $local.index
				[label] $> ${local.position} ${local.entity.label//uc1}
				[on-trigger]
					[set $fight.target] $local.enemies[$args.index]
	
	
	
	[scene pc-melee-fighting]
		[if $fight.distance = 0]
			[gosub pc-targeting]
		[call melee-fighting]
			performer: $fight.entityTurn
			target: $fight.target
		[return]
	
	
	
	[scene pc-ranged-fighting]
		[gosub pc-targeting]
		[call ranged-fighting]
			performer: $fight.entityTurn
			target: $fight.target
		[return]
	
	
	
	[scene pc-charge]
		[if $fight.distance = 0]
			[gosub pc-targeting]
		[call charge]
			performer: $fight.entityTurn
			target: $fight.target
		[return]
	
	
	
	[fn deal-damages]
		[if $args.target]
			[set $target] $args.target
		
		[set $local.usage] $= $args.usage ? $args.usage "melee-fighting"
		[set $local.faces] $= $args.faces ? $args.faces 6
		
		# Damage level
		[if $args.damages is-real?]
			[set $local.attackScore] $= $args.damages + ( 2 D $local.faces )
		[else]
			[set $local.attackScore] $= $performer.actualUsages[$local.usage].compound.damages + ( 2 D $local.faces )
			
			# Attacker offensiveness is used only when not using fixed damage base
			[if $performer.adhoc.fight.offensiveness > 0]
				[add $local.attackScore] 2
			[elseif $performer.adhoc.fight.offensiveness < 0]
				[sub $local.attackScore] 3
			
		
		[set $local.defenseScore] $= $target.actual.stats.resilience + ( 2 D 6 )
		
		# Always used?
		[if $target.adhoc.fight.offensiveness > 0]
			[sub $local.defenseScore] 3
		[elseif $target.adhoc.fight.offensiveness < 0]
			[add $local.defenseScore] 2
		
		#[message] $> ${local.attackScore} vs ${local.defenseScore}
		
		[set $damages] $= ( ( $local.attackScore - $local.defenseScore ) + ( random ) ) - 0.5
		
		
		[if $args.bonus is-real?]
			[add $damages] $args.bonus
		
		#[message] $> damages: ${damages}
		
		# This is the magic formula that transform damage levels into real hit point loss, with the correct feeling
		# damage-level = +20 is needed for an instant death
		[set $damages] $= round ( 10 * ( 2 ^ ( $damages / 6 ) ) )
		
		#[message] $> damages: ${damages}
		
		[sub $target.status.hp] $damages
		
		[if $damages >= 100]
			[if $args.fatalHitFlavour is-set?]
				[apply-to $local.flavour] $args.fatalHitFlavour
			[elseif $args.criticalHitFlavour is-set?]
				[apply-to $local.flavour] $args.criticalHitFlavour
			[elseif $args.hitFlavour is-set?]
				[apply-to $local.flavour] $args.hitFlavour
			[elseif $performer.actualUsages[$local.usage].params.fatalHitFlavour is-set?]
				[apply-to $local.flavour] $performer.actualUsages[$local.usage].params.fatalHitFlavour
			[elseif $performer.actualUsages[$local.usage].params.criticalHitFlavour is-set?]
				[apply-to $local.flavour] $performer.actualUsages[$local.usage].params.criticalHitFlavour
			[elseif $performer.actualUsages[$local.usage].params.hitFlavour is-set?]
				[apply-to $local.flavour] $performer.actualUsages[$local.usage].params.hitFlavour
			[else]
				[set $local.flavour] $> ^r${performer.label//uc1} deadly hits ${target.label} for ${damages} hp.
		[elseif $damages >= 25]
			[if $args.criticalHitFlavour is-set?]
				[apply-to $local.flavour] $args.criticalHitFlavour
			[elseif $args.hitFlavour is-set?]
				[apply-to $local.flavour] $args.hitFlavour
			[elseif $performer.actualUsages[$local.usage].params.criticalHitFlavour is-set?]
				[apply-to $local.flavour] $performer.actualUsages[$local.usage].params.criticalHitFlavour
			[elseif $performer.actualUsages[$local.usage].params.hitFlavour is-set?]
				[apply-to $local.flavour] $performer.actualUsages[$local.usage].params.hitFlavour
			[else]
				[set $local.flavour] $> ^r${performer.label//uc1} critically hits ${target.label} for ${damages} hp.
		[else]
			[if $args.hitFlavour is-set?]
				[apply-to $local.flavour] $args.hitFlavour
			[elseif $performer.actualUsages[$local.usage].params.hitFlavour is-set?]
				[apply-to $local.flavour] $performer.actualUsages[$local.usage].params.hitFlavour
			[else]
				[set $local.flavour] $> ^r${performer.label//uc1} hits ${target.label} for ${damages} hp.
		
		[message] $local.flavour
		
		[if $target.status.hp <= 0]
			[message] $> ^R^+${target.label//uc1} is dead.
	
	
	
	[fn splash-effect]
		#[debug info] $args
		
		[foreach $fight.aliveEntities => $target]
			
			[if $args.exclude has $target]
				[continue]
			
			[set $targetPos] $target.adhoc.fight.position
			
			[if ( hypot ( $targetPos.x - $args.position.x ) ( $targetPos.y - $args.position.y ) ) <= $args.radius]
				
				[set $local.attackScore] $= $args.attack + ( 2 D 8 )
				[set $local.defenseScore] $= $target.actualUsages.ranged-fighting.compound.defense + ( 2 D 8 )
				
				[call pressure] $target
				
				[if $target.adhoc.fight.offensiveness > 0]
					[sub $local.defenseScore] 3
					[sub $local.defenseScore] $= ceil ( $target.adhoc.fight.pressure / 2 )
				[elseif $target.adhoc.fight.offensiveness < 0]
					[add $local.defenseScore] 2
					# Less sensible to the pressure when defending
					[sub $local.defenseScore] $= ceil ( $target.adhoc.fight.pressure / 4 )
				[else]
					[sub $local.defenseScore] $= ceil ( $target.adhoc.fight.pressure / 2 )
				
				[if $local.attackScore > $local.defenseScore]
					[call deal-damages]
						target: $target
						hitFlavour: $args.hitFlavour
						criticalHitFlavour: $args.criticalHitFlavour
						fatalHitFlavour: $args.fatalHitFlavour
						damages: $args.damages
				
				[else]
					[if $args.missFlavour]
						[apply-to $flavour] $args.missFlavour
						[message] $flavour
			
	
	
	[fn melee-fighting]
		[set $performer] $args.performer
		[set $target] $args.target
		
		[set $performer.adhoc.fight.speed] $= $performer.adhoc.fight.offensiveness ??? 2 4 6
		
		[if $fight.distance > 0]
			[set $performer.adhoc.fight.pressTarget] null
			[set $performer.adhoc.fight.pressValue] 0
			
			[if $performer.adhoc.fight.offensiveness > 0]
				[message] $> ${performer.label//uc1} runs toward the opposing crew.
			[elseif $performer.adhoc.fight.offensiveness < 0]
				[message] $> ${performer.label//uc1} walk cautiously toward the opposing crew.
			[else]
				[message] $> ${performer.label//uc1} marches toward the opposing crew.
			
			[return]
			
		
		[set $local.attackScore] $= $performer.actualUsages.melee-fighting.compound.attack + ( 2 D 8 )
		[set $local.defenseScore] $= $target.actualUsages.melee-fighting.compound.defense + ( 2 D 8 )
		
		[set $performer.adhoc.fight.pressTarget] $target
		[set $performer.adhoc.fight.pressValue] $= $performer.adhoc.fight.offensiveness ??? 3 4 6
		
		[call pressure] $performer
		[call pressure] $target
		
		#[message] $> Pressure -- ${performer.adhoc.fight.pressure} / ${target.adhoc.fight.pressure}
		#[message] $> A: ${local.attackScore} vs ${local.defenseScore}
		
		[if $performer.adhoc.fight.offensiveness > 0]
			[add $local.attackScore] 2
			# Less sensible to the pressure when attacking
			[sub $local.attackScore] $= ceil ( $performer.adhoc.fight.pressure / 4 )
		[elseif $performer.adhoc.fight.offensiveness < 0]
			[sub $local.attackScore] 3
			[sub $local.attackScore] $= ceil ( $performer.adhoc.fight.pressure / 2 )
		[else]
			[sub $local.attackScore] $= ceil ( $performer.adhoc.fight.pressure / 2 )
		
		[if $target.adhoc.fight.offensiveness > 0]
			[sub $local.defenseScore] 3
			[sub $local.defenseScore] $= ceil ( $target.adhoc.fight.pressure / 2 )
		[elseif $target.adhoc.fight.offensiveness < 0]
			[add $local.defenseScore] 2
			# Less sensible to the pressure when defending
			[sub $local.defenseScore] $= ceil ( $target.adhoc.fight.pressure / 4 )
		[else]
			[sub $local.defenseScore] $= ceil ( $target.adhoc.fight.pressure / 2 )
		
		#[message] $> B: ${local.attackScore} vs ${local.defenseScore}
		
		[if $local.attackScore > $local.defenseScore]
			[call deal-damages]
			
		[else]
			[fortune]
				- $> ${performer.label//uc1} misses ${target.label}.
				- $> ${target.label//uc1} blocks ${performer.label}.
				- $> ${target.label//uc1} avoids ${performer.label}.
	
	
	
	[fn ranged-fighting]
		[set $performer] $args.performer
		[set $target] $args.target
		
		[set $item] $performer.primary.ranged-fighting
		
		[if $item.usages.ranged-fighting.primary.params.projectileLabel]
			[set $projectile.label] $item.usages.ranged-fighting.primary.params.projectileLabel
		[else]
			[set $projectile] $item
		
		#[debug info] $projectile
		#[debug info] $item.usages.ranged-fighting.primary.params.projectileLabel
		
		[set $performer.adhoc.fight.speed] 0
		[set $performer.adhoc.fight.offensiveness] -1
		
		[if ! $performer.primary.ranged-fighting]
			# Should never happen
			[set $performer.adhoc.fight.pressTarget] null
			[set $performer.adhoc.fight.pressValue] 0
			[message] $> ${performer.label//uc1} can't fire anything.
			[return]
		
		[set $performer.adhoc.fight.pressTarget] $target
		[set $performer.adhoc.fight.pressValue] 4
		
		[call pressure] $performer
		[call pressure] $target
		
		[if $performer.actualUsages.ranged-fighting.params.spellLevel is-set?]
			[call spellcasting/cast => $local.casted]
				performer: $performer
				item: $item
				usage: $performer.actualUsages.ranged-fighting
				bonus: $= - ( ceil ( $performer.adhoc.fight.pressure / 4 ) )
			[if ! $local.casted]
				[return]
		
		# We are in close range, we have to test first with the closeRange stat,
		# against the best of the opponent melee-fighting attack or defense stat.
		[if $fight.distance = 0]
			[set $local.attackScore] $= $performer.actualUsages.ranged-fighting.compound.close-ranged + ( 2 D 8 )
			[set $local.defenseScore] $= $target.actualUsages.melee-fighting.compound.anti-ranged + ( 2 D 8 )
			
			#[message] $> Close range A: ${local.attackScore} vs ${local.defenseScore}
			#[message] $> Pressure: ${performer.adhoc.fight.pressure}
			
			[sub $local.attackScore] $= ceil ( $performer.adhoc.fight.pressure / 2 )
			
			[if $target.adhoc.fight.offensiveness > 0]
				[sub $local.defenseScore] 3
				[sub $local.defenseScore] $= ceil ( $target.adhoc.fight.pressure / 2 )
			[elseif $target.adhoc.fight.offensiveness < 0]
				[add $local.defenseScore] 2
				# Less sensible to the pressure when defending
				[sub $local.defenseScore] $= ceil ( $target.adhoc.fight.pressure / 4 )
			[else]
				[sub $local.defenseScore] $= ceil ( $target.adhoc.fight.pressure / 2 )
			
			#[message] $> Close range B: ${local.attackScore} vs ${local.defenseScore}
			
			[if $local.attackScore <= $local.defenseScore]
				[message] $> ${target.label//uc1} prevents ${performer.label} from attacking from afar.
				[return]
		
		[set $local.aimingScore] $= $performer.actualUsages.ranged-fighting.compound.aiming + ( 2 D 12 )
		[set $local.guardScore] $= ( $fight.distance / 2 ) + ( abs $target.adhoc.fight.speed ) + ( 2 D 12 )
		
		#[message] $> Aiming A: ${local.aimingScore} vs ${local.guardScore}
		#[message] $> Pressure: ${performer.adhoc.fight.pressure}
		
		[sub $local.aimingScore] $= ceil ( $performer.adhoc.fight.pressure / 2 )
		
		#[message] $> Aiming B: ${local.aimingScore} vs ${local.guardScore}
		
		[if $local.aimingScore < $local.guardScore]
			[message] $> ${performer.label//uc1} misses ${target.label}.
			[return]
		
		#[message] $> Guard: ${target.actualUsages.ranged-fighting.compound.guard}
		#[debug info] $target.equippedItems.hand[0]
		#[debug info] $target.actualUsages.ranged-fighting
		
		[add $local.guardScore] $target.actualUsages.ranged-fighting.compound.guard
		
		[if $local.aimingScore < $local.guardScore]
			[if $target.actualUsages.ranged-fighting.params.guardFlavour is-set?]
				[apply-to $local.flavour] $target.actualUsages.ranged-fighting.params.guardFlavour
				[message] $local.flavour
			[else]
				[message] $> ${performer.label//uc1} misses ${target.label}.
			[return]
		
		[set $local.attackScore] $= $performer.actualUsages.ranged-fighting.compound.attack + ( 2 D 12 )
		[set $local.defenseScore] $= $target.actualUsages.ranged-fighting.compound.defense + ( 2 D 12 )
		
		# The longer the distance, the better the chance to evade the ranged-fighting
		[sub $local.attackScore] $= floor ( $fight.distance / 8 )
		
		#[message] $> Pressure -- ${performer.adhoc.fight.pressure} / ${target.adhoc.fight.pressure}
		#[message] $> A: ${local.attackScore} vs ${local.defenseScore}
		
		# Attack score of ranged-fighting do not depend much on the character but on the weapon
		#[sub $local.attackScore] $= ceil ( $performer.adhoc.fight.pressure / 2 )
		
		[if $target.adhoc.fight.offensiveness > 0]
			[sub $local.defenseScore] 3
			[sub $local.defenseScore] $= ceil ( $target.adhoc.fight.pressure / 2 )
		[elseif $target.adhoc.fight.offensiveness < 0]
			[add $local.defenseScore] 2
			# Less sensible to the pressure when defending
			[sub $local.defenseScore] $= ceil ( $target.adhoc.fight.pressure / 4 )
		[else]
			[sub $local.defenseScore] $= ceil ( $target.adhoc.fight.pressure / 2 )
		
		#[message] $> B: ${local.attackScore} vs ${local.defenseScore}
		
		[if $local.attackScore > $local.defenseScore]
			[call deal-damages]
				faces: $= ( $performer.primary.ranged-fighting.class = "ability" ) ? 6 10
				usage: ranged-fighting
			
			[if $performer.actualUsages.ranged-fighting.params.splash]
				[call splash-effect]
					exclude:
						- $performer
						- $target
					position: $target.adhoc.fight.position
					attack: $= $performer.actualUsages.ranged-fighting.compound.attack + $performer.actualUsages.ranged-fighting.params.splash.attack
					damages: $= $performer.actualUsages.ranged-fighting.compound.damages + $performer.actualUsages.ranged-fighting.params.splash.damages
					radius: $performer.actualUsages.ranged-fighting.params.splash.radius
					missFlavour: $performer.actualUsages.ranged-fighting.params.splash.missFlavour
					hitFlavour: $performer.actualUsages.ranged-fighting.params.splash.hitFlavour
					criticalHitFlavour: $performer.actualUsages.ranged-fighting.params.splash.criticalHitFlavour
					fatalHitFlavour: $performer.actualUsages.ranged-fighting.params.splash.fatalHitFlavour
			
		[else]
			[fortune]
				- $> ${target.label//uc1} blocks ${performer.label}'s ${projectile.label}.
				- $> ${target.label//uc1} avoids ${performer.label}'s ${projectile.label}.
	
	
	
	[fn charge]
		[set $performer] $args.performer
		[set $target] $args.target
		
		[set $performer.adhoc.fight.speed] 10
		[set $performer.adhoc.fight.offensiveness] 1
		
		[if $fight.distance > 0]
			[set $performer.adhoc.fight.pressTarget] null
			[set $performer.adhoc.fight.pressValue] 0
			[message] $> ${performer.label//uc1} charges toward the opposing crew.
			[return]
		
		
		[set $local.attackScore] $= $performer.actualUsages.melee-fighting.compound.attack + ( 2 D 8 )
		[set $local.defenseScore] $= $target.actualUsages.melee-fighting.compound.defense + ( 2 D 8 )
		
		[set $performer.adhoc.fight.pressTarget] $target
		[set $performer.adhoc.fight.pressValue] 6
		
		[call pressure] $performer
		[call pressure] $target
		
		#[message] $> Pressure -- ${performer.adhoc.fight.pressure} / ${target.adhoc.fight.pressure}
		#[message] $> A: ${local.attackScore} vs ${local.defenseScore}
		
		# A charge is always offensive!
		[add $local.attackScore] 2
		# Charge is less sensible to the pressure
		[sub $local.attackScore] $= ceil ( $performer.adhoc.fight.pressure / 4 )
		
		[if $target.adhoc.fight.offensiveness > 0]
			[sub $local.defenseScore] 3
			[sub $local.defenseScore] $= ceil ( $target.adhoc.fight.pressure / 2 )
		[elseif $target.adhoc.fight.offensiveness < 0]
			[add $local.defenseScore] 2
			# Less sensible to the pressure when defending
			[sub $local.defenseScore] $= ceil ( $target.adhoc.fight.pressure / 4 )
		[else]
			[sub $local.defenseScore] $= ceil ( $target.adhoc.fight.pressure / 2 )
		
		#[message] $> B: ${local.attackScore} vs ${local.defenseScore}
		
		[message] $> ${performer.label//uc1} charges ${target.label}!
		
		[if $local.attackScore > $local.defenseScore]
			[call deal-damages]
			
			[if $fight.deadlyPush]
				[call deadly-push]
		[elseif ( $local.attackScore = $local.defenseScore ) && $fight.deadlyPush]
			[message] $> ${target.label//uc1} blocks ${performer.label}.
			[call deadly-push]
		[else]
			[fortune]
				- $> ${performer.label//uc1} misses ${target.label}.
				- $> ${target.label//uc1} blocks ${performer.label}.
				- $> ${target.label//uc1} avoids ${performer.label}.
	
	
	
	[fn deadly-push]
		[set $local.attackScore] $= ( ( max $performer.actual.stats.strength ( $performer.actual.stats.fighting - 3 ) ) + $fight.deadlyPush.bonus ) + ( 2 D 6 )
		[set $local.defenseScore] $= $target.actual.stats.strength + ( 2 D 6 )
		
		[sub $local.attackScore] $= $performer.adhoc.fight.pressure / 4
		[sub $local.defenseScore] $= $target.adhoc.fight.pressure / 4
		
		#[message] $> Attacker ${performer.label} offensiveness: ${performer.adhoc.fight.offensiveness}
		[if $performer.adhoc.fight.offensiveness > 0]
			[add $local.attackScore] 2
			#[message] Offensive: bonus!
		[elseif $performer.adhoc.fight.offensiveness < 0]
			[sub $local.attackScore] 3
			#[message] Defensive: malus!
		
		#[message] $> Defender ${target.label} offensiveness: ${target.adhoc.fight.offensiveness}
		[if $target.adhoc.fight.offensiveness > 0]
			[sub $local.defenseScore] 3
			#[message] Offensive: malus!
		[elseif $target.adhoc.fight.offensiveness < 0]
			[add $local.defenseScore] 2
			#[message] Defensive: bonus!
		
		[if $local.attackScore > $local.defenseScore]
			[set $target.status.hp] 0
			[apply-to $local.flavour] $fight.deadlyPush.flavour
			[message] $local.flavour
		
		
	
	
