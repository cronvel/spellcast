
[[doctype adventurer]]

[chapter battle]
	
	[scene init]
		[set $battle] <Object>
		
		[set $battle.foes] <Array>
		[set $battle.turnIndex] 0
		[set $battle.round] 0
		[set $battle.turns] <Array>
		[set $battle.distance] $= ( $args.distance is-set? ) ? ( floor ( abs $args.distance ) 2 ) 0
		
		[foreach $args.foes => $local.index : $local.foe]
			[if ! ( $local.foe is-entity? )]
				[create-entity $local.foe] $local.foe
			[set $battle.foes[$local.index]] $local.foe
			[append $battle.turns] $local.foe
			[set $local.foe.adhoc.battle]
				side: foes
				cooldown: 0
				offensiveness: $= ( $local.foe.stances.offensiveness is-set? ) ? $local.foe.stances.offensiveness 0
				pressTarget: null
				pressure: 0
				speed: 0
			
		[foreach $args.allies => $local.index : $local.ally]
			[if ! ( $local.ally is-entity? )]
				[create-entity $local.ally] $local.ally
			[set $battle.allies[$local.index]] $local.ally
			[append $battle.turns] $local.ally
			[set $local.ally.adhoc.battle]
				side: allies
				cooldown: 0
				offensiveness: $= ( $local.ally.stances.offensiveness is-set? ) ? $local.ally.stances.offensiveness 0
				pressTarget: null
				pressure: 0
				speed: 0
			
		[filter $battle.foes => $battle.aliveFoes] $= $this.status.hp > 0
		[filter $battle.allies => $battle.aliveAllies] $= $this.status.hp > 0
		
		#[debug info] $battle.allies
		#[debug info] $battle.foes
		#[debug info] $battle.aliveFoes
		#[debug info] $battle.turns
		
		[set $battle.deadlyPush] $args.deadlyPush
		
		[next initiative]
	
	
	
	[scene initiative]
		[foreach $battle.turns => $local.entity]
			[set $local.entity.adhoc.battle.initiativeScore] $= $local.entity.actual.stats.fighting + ( 2 D 8 )
		
			[if $local.entity.adhoc.battle.offensiveness > 0]
				[add $local.entity.adhoc.battle.initiativeScore] 2
			[elseif $local.entity.adhoc.battle.offensiveness < 0]
				[sub $local.entity.adhoc.battle.initiativeScore] 3
		
		#[sort $battle.turns] $= - $this.adhoc.battle.initiativeScore
		[sort $battle.turns] $= $this.right.adhoc.battle.initiativeScore - $this.left.adhoc.battle.initiativeScore
		
		#[debug info] $battle.turns
		[message] $> ^yThe distance between opponents is ${battle.distance} ${battle.distance}[n?step|steps].
		[message] $> ${battle.turns[0].label//uc1} takes the initiative.
		[goto new-turn]
		
	
	
	[scene new-turn]
		[set $battle.entityTurn] $= $battle.turns[$battle.turnIndex]
		
		[if $battle.entityTurn.status.hp <= 0]
			[goto end-turn]
		
		[if $battle.entityTurn.adhoc.battle.cooldown > 0]
			[dec $battle.entityTurn.adhoc.battle.cooldown]
			[goto end-turn]
		
		[gosub battle-lines]
		
		[if $battle.entityTurn.npc]
			[goto npc-turn]
		[else]
			[goto pc-turn]
	
	
	
	[scene end-turn]
		[set $battle.turnIndex] $= ( $battle.turnIndex + 1 ) % $battle.turns.length
		
		[if $battle.turnIndex = 0]
			[call battle/new-round]
		
		[filter $battle.foes => $battle.aliveFoes] $= $this.status.hp > 0
		[filter $battle.allies => $battle.aliveAllies] $= $this.status.hp > 0
		
		[if ! $battle.aliveAllies.length]
			[goto lost]
		[elseif ! $battle.aliveFoes.length]
			[goto win]
		
		[goto new-turn]
	
	
	
	[fn battle/new-round]
		[inc $battle.round]
		
		# Manage distance
		[if $battle.distance > 0]
			[map $battle.aliveAllies => $local.alliesSpeed] $this.adhoc.battle.speed
			[map $battle.aliveFoes => $local.foesSpeed] $this.adhoc.battle.speed
			
			[set $battle.distance] $= max 0 ( trunc ( $battle.distance - ( avg $local.alliesSpeed ) - ( avg $local.foesSpeed ) ) 2 )
			
			[if $battle.distance = 0]
				[message] $> ^yThe two opposing crews join together and clash.
			[else]
				[message] $> ^yThe remaining distance between opponents is ${battle.distance} ${battle.distance}[n?step|steps].
		
	
	
	[fn battle/all-pressure]
		[foreach $battle.aliveEntities => $local.entity]
			[call battle/pressure] $local.entity
		
	[fn battle/pressure]
		[reduce $battle.aliveEntities , 0 => $args.adhoc.battle.pressure] $= $this.previous + ( ( $this.current.adhoc.battle.pressTarget = $args ) ? $this.current.adhoc.battle.pressValue 0 )
		# Pressure has a max level, because when the target is saturated,
		# extra opponents are not able to reach the target properly:
		# both the target and its opponents get some malus, therefore the pressure is capped to 18 (4 charging opponents)
		[set $args.adhoc.battle.pressure] $= min ( max 0 ( $args.adhoc.battle.pressure - 6 ) ) 18
		
		
		
	[scene battle-lines]
		
		[filter $battle.aliveFoes => $front] $= $this.adhoc.battle.offensiveness > 0
		[filter $battle.aliveFoes => $middle] $= $this.adhoc.battle.offensiveness = 0
		[filter $battle.aliveFoes => $back] $= $this.adhoc.battle.offensiveness < 0
		
		[set $offset] $= ceil ( ( 1 - $front.length ) / 2 )
		[foreach $front => $index : $entity]
			[set $entity.adhoc.battle.position]
				x: $= $battle.distance / 2
				y: $= $index + $offset
		
		[set $offset] $= ceil ( ( 1 - $middle.length ) / 2 )
		[foreach $middle => $index : $entity]
			[set $entity.adhoc.battle.position]
				x: $= ( $battle.distance / 2 ) + 1
				y: $= $index + $offset
		
		[set $offset] $= ceil ( ( 1 - $back.length ) / 2 )
		[foreach $back => $index : $entity]
			[set $entity.adhoc.battle.position]
				x: $= ( $battle.distance / 2 ) + 2
				y: $= $index + $offset
		
		#[sort $battle.aliveFoes] $= $this.adhoc.battle.position.y + ( $this.adhoc.battle.position.x / 1000 )
		[sort $battle.aliveFoes] $= ( $this.left.adhoc.battle.position.y + ( $this.left.adhoc.battle.position.x / 1000 ) ) - ( $this.right.adhoc.battle.position.y + ( $this.right.adhoc.battle.position.x / 1000 ) )
		
		#[map $battle.aliveFoes => $tmp] $this.adhoc.battle
		#[debug info] $tmp
		
		# Same for allies
		
		[filter $battle.aliveAllies => $front] $= $this.adhoc.battle.offensiveness > 0
		[filter $battle.aliveAllies => $middle] $= $this.adhoc.battle.offensiveness = 0
		[filter $battle.aliveAllies => $back] $= $this.adhoc.battle.offensiveness < 0
		
		[set $offset] $= ceil ( ( 1 - $front.length ) / 2 )
		[foreach $front => $index : $entity]
			[set $entity.adhoc.battle.position]
				x: $= - ( $battle.distance / 2 )
				y: $= $index + $offset
		
		[set $offset] $= ceil ( ( 1 - $middle.length ) / 2 )
		[foreach $middle => $index : $entity]
			[set $entity.adhoc.battle.position]
				x: $= ( - ( $battle.distance / 2 ) ) - 1
				y: $= $index + $offset
		
		[set $offset] $= ceil ( ( 1 - $back.length ) / 2 )
		[foreach $back => $index : $entity]
			[set $entity.adhoc.battle.position]
				x: $= ( - ( $battle.distance / 2 ) ) - 2
				y: $= $index + $offset
			
		#[sort $battle.aliveAllies] $= $this.adhoc.battle.position.y + ( $this.adhoc.battle.position.x / 1000 )
		[sort $battle.aliveAllies] $= ( $this.left.adhoc.battle.position.y + ( $this.left.adhoc.battle.position.x / 1000 ) ) - ( $this.right.adhoc.battle.position.y + ( $this.right.adhoc.battle.position.x / 1000 ) )
		[set $battle.aliveEntities] $= concat $battle.aliveFoes $battle.aliveAllies
		
		
	
	[scene npc-turn]
		
		[gosub npc-targeting]
		
		[set $performer] $battle.entityTurn
		
		[if $performer.params.battleCry && ( ( random ) <= $performer.params.battleCry )]
			[if $performer.params.battleCryFlavour]
				[apply-to $local.flavour] $= random-element $performer.params.battleCryFlavour
				[message] $local.flavour
			[else]
				[message] $> ${performer.label//uc1} shouts!
		
		
		[if $performer.params.charge && ( ( random ) <= $performer.params.charge )]
			[gosub charge]
				[args]
					performer: $performer
					target: $battle.target
			[goto end-turn]
		
		[gosub melee]
			[args]
				performer: $performer
				target: $battle.target
		
		[goto end-turn]
		
	
	
	[scene pc-turn]
		[if $battle.distance = 0]
			[set $local.item] $battle.entityTurn.primary.melee
			
			[if $local.item.usages.melee.primary.params.menuLabel]
				[set $local.label] $local.item.usages.melee.primary.params.menuLabel
			[else]
				[set $local.label] $> fight
			
			[next pc-melee]
				[label] $> ${local.label//uc1}
				[on-trigger]
					[set $battle.entityTurn.adhoc.battle.offensiveness] 0
			
			[next pc-melee]
				[label] $> ${local.label//uc1} boldly
				[on-trigger]
					[set $battle.entityTurn.adhoc.battle.offensiveness] 1
			
			[next pc-melee]
				[label] $> ${local.label//uc1} cautiously
				[on-trigger]
					[set $battle.entityTurn.adhoc.battle.offensiveness] -1
		[else]
			[next pc-melee]
				[label] $> March
				[on-trigger]
					[set $battle.entityTurn.adhoc.battle.offensiveness] 0
			
			[next pc-melee]
				[label] $> March boldly
				[on-trigger]
					[set $battle.entityTurn.adhoc.battle.offensiveness] 1
			
			[next pc-melee]
				[label] $> March cautiously
				[on-trigger]
					[set $battle.entityTurn.adhoc.battle.offensiveness] -1
		
		[next pc-charge]
			[label] Charge!
	
		#[if ( $battle.distance > 0 ) && ( $battle.entityTurn.primary.missile )]
		[if $battle.entityTurn.primary.missile]
			[set $local.item] $battle.entityTurn.primary.missile
			
			[if $local.item.usages.missile.primary.params.menuLabel]
				[set $local.label] $local.item.usages.missile.primary.params.menuLabel
			[else]
				[set $local.label] $> Shoot
			
			[next pc-missile]
				[label] $> ${local.label//uc1}
		
		#[next inventory/equip-ability]
		#	[label] Choose an ability
	
		[next pc-turn]
			[label] Select primary ability or object
			[on-trigger]
				[gosub inventory/select-ability-choose-primary]
					[args]
						performer: $battle.entityTurn
	
		[next pc-turn]
			[label] Equip object in hand
			[on-trigger]
				[gosub inventory/equip-object => $local.changed]
					[args]
						performer: $battle.entityTurn
						slot: hand
				[if $local.changed]
					[set $battle.entityTurn.adhoc.battle.speed] 0
					[set $battle.entityTurn.adhoc.battle.offensiveness] -1
					[set $battle.entityTurn.adhoc.battle.pressTarget] null
					[set $battle.entityTurn.adhoc.battle.pressValue] 0
					[goto end-turn]
	
	
	
	[scene npc-targeting]
		
		[if $battle.entityTurn.adhoc.battle.side = "allies"]
			[set $local.enemies] $battle.aliveFoes
		[else]
			[set $local.enemies] $battle.aliveAllies
		
		[set $local.index] $= random ( $local.enemies.length - 1 )
		[set $battle.target] $local.enemies[$local.index]
	
	
	
	[scene pc-targeting]
		[set $local.count] 0
		
		[if $battle.entityTurn.adhoc.battle.side = "allies"]
			[set $local.enemies] $battle.aliveFoes
		[else]
			[set $local.enemies] $battle.aliveAllies
		
		[if $local.enemies.length <= 1]
			[set $battle.target] $local.enemies[0]
			[return]
		
		[message] Target?
		
		[foreach $local.enemies => $local.index : $local.entity]
			[if $local.entity.adhoc.battle.offensiveness > 0]
				[set $local.position] "←"
			[elseif $local.entity.adhoc.battle.offensiveness < 0]
				[set $local.position] "→    "
			[else]
				[set $local.position] "   "
			
			[next]
				[args]
					index: $local.index
				[label] $> ${local.position} ${local.entity.label//uc1}
				[on-trigger]
					[set $battle.target] $local.enemies[$args.index]
	
	
	
	[scene pc-melee]
		[if $battle.distance = 0]
			[gosub pc-targeting]
		[gosub melee]
			[args]
				performer: $battle.entityTurn
				target: $battle.target
		[goto end-turn]
	
	
	
	[scene pc-missile]
		[gosub pc-targeting]
		[gosub missile]
			[args]
				performer: $battle.entityTurn
				target: $battle.target
		[goto end-turn]
	
	
	
	[scene pc-charge]
		[if $battle.distance = 0]
			[gosub pc-targeting]
		[gosub charge]
			[args]
				performer: $battle.entityTurn
				target: $battle.target
		[goto end-turn]
	
	
	
	[scene win]
		[message] $> ${battle.allies[0].label//uc1} win the battle.
		[set $local.xpReward] 0
		
		[foreach $battle.foes => $local.entity]
			[add $local.xpReward] $local.entity.params.xpReward
		
		[set $local.xpReward] $= ceil ( $local.xpReward / $battle.allies.length )
		
		[foreach $battle.allies => $local.index : $local.entity]
			[add $local.entity.status.xp] $local.xpReward
		
		[message] $> You gain ${local.xpReward} xp (=${battle.allies[0].status.xp}).
	
	
	
	[scene lost]
		[message] $> ${battle.allies[0].label//uc1} died on the battlefield.
		[lost]

	
	
	#melee damage
	[scene deal-damages]
		[if $args.target]
			[set $target] $args.target
		
		[set $local.usage] $= $args.usage ? $args.usage "melee"
		[set $local.faces] $= $args.faces ? $args.faces 6
		
		# Damage level
		[if $args.damages is-real?]
			[set $local.attackScore] $= $args.damages + ( 2 D $local.faces )
		[else]
			[set $local.attackScore] $= $performer.actualUsages[$local.usage].compound.damages + ( 2 D $local.faces )
			
			# Attacker offensiveness is used only when not using fixed damage base
			[if $performer.adhoc.battle.offensiveness > 0]
				[add $local.attackScore] 2
			[elseif $performer.adhoc.battle.offensiveness < 0]
				[sub $local.attackScore] 3
			
		
		[set $local.defenseScore] $= $target.actual.stats.resilience + ( 2 D 6 )
		
		# Always used?
		[if $target.adhoc.battle.offensiveness > 0]
			[sub $local.defenseScore] 3
		[elseif $target.adhoc.battle.offensiveness < 0]
			[add $local.defenseScore] 2
		
		#[message] $> ${local.attackScore} vs ${local.defenseScore}
		
		[set $damages] $= ( ( $local.attackScore - $local.defenseScore ) + ( random ) ) - 0.5
		
		
		[if $args.bonus is-real?]
			[add $damages] $args.bonus
		
		#[message] $> damages: ${damages}
		
		# This is the magic formula that transform damage levels into real hit point loss, with the correct feeling
		# damage-level = +20 is needed for an instant death
		[set $damages] $= round ( 10 * ( 2 ^ ( $damages / 6 ) ) )
		
		#[message] $> damages: ${damages}
		
		[sub $target.status.hp] $damages
		
		[if $damages >= 100]
			[if $args.fatalHitFlavour is-set?]
				[apply-to $local.flavour] $args.fatalHitFlavour
			[elseif $args.criticalHitFlavour is-set?]
				[apply-to $local.flavour] $args.criticalHitFlavour
			[elseif $args.hitFlavour is-set?]
				[apply-to $local.flavour] $args.hitFlavour
			[elseif $performer.actualUsages[$local.usage].params.fatalHitFlavour is-set?]
				[apply-to $local.flavour] $performer.actualUsages[$local.usage].params.fatalHitFlavour
			[elseif $performer.actualUsages[$local.usage].params.criticalHitFlavour is-set?]
				[apply-to $local.flavour] $performer.actualUsages[$local.usage].params.criticalHitFlavour
			[elseif $performer.actualUsages[$local.usage].params.hitFlavour is-set?]
				[apply-to $local.flavour] $performer.actualUsages[$local.usage].params.hitFlavour
			[else]
				[set $local.flavour] $> ^r${performer.label//uc1} deadly hits ${target.label} for ${damages} hp.
		[elseif $damages >= 25]
			[if $args.criticalHitFlavour is-set?]
				[apply-to $local.flavour] $args.criticalHitFlavour
			[elseif $args.hitFlavour is-set?]
				[apply-to $local.flavour] $args.hitFlavour
			[elseif $performer.actualUsages[$local.usage].params.criticalHitFlavour is-set?]
				[apply-to $local.flavour] $performer.actualUsages[$local.usage].params.criticalHitFlavour
			[elseif $performer.actualUsages[$local.usage].params.hitFlavour is-set?]
				[apply-to $local.flavour] $performer.actualUsages[$local.usage].params.hitFlavour
			[else]
				[set $local.flavour] $> ^r${performer.label//uc1} critically hits ${target.label} for ${damages} hp.
		[else]
			[if $args.hitFlavour is-set?]
				[apply-to $local.flavour] $args.hitFlavour
			[elseif $performer.actualUsages[$local.usage].params.hitFlavour is-set?]
				[apply-to $local.flavour] $performer.actualUsages[$local.usage].params.hitFlavour
			[else]
				[set $local.flavour] $> ^r${performer.label//uc1} hits ${target.label} for ${damages} hp.
		
		[message] $local.flavour
		
		[if $target.status.hp <= 0]
			[message] $> ^R^+${target.label//uc1} is dead.
	
	
	
	[scene splash-damages]
		[set $pos] $target.adhoc.battle.position
		
		#[debug info] $args
		
		[foreach $battle.aliveEntities => $currentTarget]
			
			[if ( $currentTarget = $target ) || ( $currentTarget = $performer )]
				[continue]
			
			[set $currentTargetPos] $currentTarget.adhoc.battle.position
			
			[if ( hypot ( $currentTargetPos.x - $pos.x ) ( $currentTargetPos.y - $pos.y ) ) <= $args.radius]
				
				[set $local.attackScore] $= $args.attack + ( 2 D 8 )
				[set $local.defenseScore] $= $currentTarget.actualUsages.missile.compound.defense + ( 2 D 8 )
				
				[call battle/pressure] $currentTarget
				
				[if $currentTarget.adhoc.battle.offensiveness > 0]
					[sub $local.defenseScore] 3
					[sub $local.defenseScore] $= ceil ( $currentTarget.adhoc.battle.pressure / 2 )
				[elseif $currentTarget.adhoc.battle.offensiveness < 0]
					[add $local.defenseScore] 2
					# Less sensible to the pressure when defending
					[sub $local.defenseScore] $= ceil ( $currentTarget.adhoc.battle.pressure / 4 )
				[else]
					[sub $local.defenseScore] $= ceil ( $currentTarget.adhoc.battle.pressure / 2 )
				
				[if $local.attackScore > $local.defenseScore]
					[gosub deal-damages]
						[args]
							target: $currentTarget
							hitFlavour: $args.hitFlavour
							criticalHitFlavour: $args.criticalHitFlavour
							fatalHitFlavour: $args.fatalHitFlavour
							damages: $args.damages
				
				[else]
					[if $args.missFlavour]
						[apply-to $flavour] $args.missFlavour
						[message] $flavour
			
	
	
	[scene melee]
		[set $performer] $args.performer
		[set $target] $args.target
		
		[set $performer.adhoc.battle.speed] $= $performer.adhoc.battle.offensiveness ??? 2 4 6
		
		[if $battle.distance > 0]
			[set $performer.adhoc.battle.pressTarget] null
			[set $performer.adhoc.battle.pressValue] 0
			
			[if $performer.adhoc.battle.offensiveness > 0]
				[message] $> ${performer.label//uc1} runs toward the opposing crew.
			[elseif $performer.adhoc.battle.offensiveness < 0]
				[message] $> ${performer.label//uc1} walk cautiously toward the opposing crew.
			[else]
				[message] $> ${performer.label//uc1} marches toward the opposing crew.
			
			[return]
			
		
		[set $local.attackScore] $= $performer.actualUsages.melee.compound.attack + ( 2 D 8 )
		[set $local.defenseScore] $= $target.actualUsages.melee.compound.defense + ( 2 D 8 )
		
		[set $performer.adhoc.battle.pressTarget] $target
		[set $performer.adhoc.battle.pressValue] $= $performer.adhoc.battle.offensiveness ??? 3 4 6
		
		[call battle/pressure] $performer
		[call battle/pressure] $target
		
		#[message] $> Pressure -- ${performer.adhoc.battle.pressure} / ${target.adhoc.battle.pressure}
		#[message] $> A: ${local.attackScore} vs ${local.defenseScore}
		
		[if $performer.adhoc.battle.offensiveness > 0]
			[add $local.attackScore] 2
			# Less sensible to the pressure when attacking
			[sub $local.attackScore] $= ceil ( $performer.adhoc.battle.pressure / 4 )
		[elseif $performer.adhoc.battle.offensiveness < 0]
			[sub $local.attackScore] 3
			[sub $local.attackScore] $= ceil ( $performer.adhoc.battle.pressure / 2 )
		[else]
			[sub $local.attackScore] $= ceil ( $performer.adhoc.battle.pressure / 2 )
		
		[if $target.adhoc.battle.offensiveness > 0]
			[sub $local.defenseScore] 3
			[sub $local.defenseScore] $= ceil ( $target.adhoc.battle.pressure / 2 )
		[elseif $target.adhoc.battle.offensiveness < 0]
			[add $local.defenseScore] 2
			# Less sensible to the pressure when defending
			[sub $local.defenseScore] $= ceil ( $target.adhoc.battle.pressure / 4 )
		[else]
			[sub $local.defenseScore] $= ceil ( $target.adhoc.battle.pressure / 2 )
		
		#[message] $> B: ${local.attackScore} vs ${local.defenseScore}
		
		[if $local.attackScore > $local.defenseScore]
			[gosub deal-damages]
			
		[else]
			[fortune]
				- $> ${performer.label//uc1} misses ${target.label}.
				- $> ${target.label//uc1} blocks ${performer.label}.
				- $> ${target.label//uc1} avoids ${performer.label}.
	
	
	
	[scene missile]
		[set $performer] $args.performer
		[set $target] $args.target
		
		# Temp:
		[set $missile] arrow
		
		[set $performer.adhoc.battle.speed] 0
		[set $performer.adhoc.battle.offensiveness] -1
		
		[if ! $performer.primary.missile]
			# Should never happen
			[set $performer.adhoc.battle.pressTarget] null
			[set $performer.adhoc.battle.pressValue] 0
			[message] $> ${performer.label//uc1} can't fire anything.
			[return]
		
		[set $performer.adhoc.battle.pressTarget] $target
		[set $performer.adhoc.battle.pressValue] 4
		
		[call battle/pressure] $performer
		[call battle/pressure] $target
		
		[if $performer.actualUsages.missile.params.spellLevel is-set?]
			[call spellcasting/cast => $local.casted]
				performer: $performer
				item: $performer.primary.missile
				usage: $performer.actualUsages.missile
				bonus: $= - ( ceil ( $performer.adhoc.battle.pressure / 4 ) )
			[if ! $local.casted]
				[return]
		
		# We are in close range, we have to test first with the closeRange stat,
		# against the best of the opponent melee attack or defense stat.
		[if $battle.distance = 0]
			[set $local.attackScore] $= $performer.actualUsages.missile.compound.closeRange + ( 2 D 8 )
			[set $local.defenseScore] $= ( max $target.actualUsages.melee.compound.defense $target.actualUsages.melee.compound.attack ) + ( 2 D 8 )
			
			#[message] $> Close range A: ${local.attackScore} vs ${local.defenseScore}
			#[message] $> Pressure: ${performer.adhoc.battle.pressure}
			
			[sub $local.attackScore] $= ceil ( $performer.adhoc.battle.pressure / 2 )
			
			[if $target.adhoc.battle.offensiveness > 0]
				[sub $local.defenseScore] 3
				[sub $local.defenseScore] $= ceil ( $target.adhoc.battle.pressure / 2 )
			[elseif $target.adhoc.battle.offensiveness < 0]
				[add $local.defenseScore] 2
				# Less sensible to the pressure when defending
				[sub $local.defenseScore] $= ceil ( $target.adhoc.battle.pressure / 4 )
			[else]
				[sub $local.defenseScore] $= ceil ( $target.adhoc.battle.pressure / 2 )
			
			#[message] $> Close range B: ${local.attackScore} vs ${local.defenseScore}
			
			[if $local.attackScore <= $local.defenseScore]
				[message] $> ${target.label//uc1} prevents ${performer.label} from attacking from afar.
				[return]
		
		[set $local.aimingScore] $= $performer.actualUsages.missile.compound.aiming + ( 2 D 12 )
		[set $local.coverScore] $= ( $battle.distance / 2 ) + ( abs $target.adhoc.battle.speed ) + ( 2 D 12 )
		
		#[message] $> Aiming A: ${local.aimingScore} vs ${local.coverScore}
		#[message] $> Pressure: ${performer.adhoc.battle.pressure}
		
		[sub $local.aimingScore] $= ceil ( $performer.adhoc.battle.pressure / 2 )
		
		#[message] $> Aiming B: ${local.aimingScore} vs ${local.coverScore}
		
		[if $local.aimingScore < $local.coverScore]
			[message] $> ${performer.label//uc1} misses ${target.label}.
			[return]
		
		#[message] $> Cover: ${target.actualUsages.missile.compound.cover}
		#[debug info] $target.equippedItems.hand[0]
		#[debug info] $target.actualUsages.missile
		
		[add $local.coverScore] $target.actualUsages.missile.compound.cover
		
		[if $local.aimingScore < $local.coverScore]
			[if $target.actualUsages.missile.params.coverFlavour is-set?]
				[apply-to $local.flavour] $target.actualUsages.missile.params.coverFlavour
				[message] $local.flavour
			[else]
				[message] $> ${performer.label//uc1} misses ${target.label}.
			[return]
		
		[set $local.attackScore] $= $performer.actualUsages.missile.compound.attack + ( 2 D 12 )
		[set $local.defenseScore] $= $target.actualUsages.missile.compound.defense + ( 2 D 12 )
		
		# The longer the distance, the better the chance to evade the missile
		[sub $local.attackScore] $= floor ( $battle.distance / 8 )
		
		#[message] $> Pressure -- ${performer.adhoc.battle.pressure} / ${target.adhoc.battle.pressure}
		#[message] $> A: ${local.attackScore} vs ${local.defenseScore}
		
		# Attack score of missile do not depend much on the character but on the weapon
		#[sub $local.attackScore] $= ceil ( $performer.adhoc.battle.pressure / 2 )
		
		[if $target.adhoc.battle.offensiveness > 0]
			[sub $local.defenseScore] 3
			[sub $local.defenseScore] $= ceil ( $target.adhoc.battle.pressure / 2 )
		[elseif $target.adhoc.battle.offensiveness < 0]
			[add $local.defenseScore] 2
			# Less sensible to the pressure when defending
			[sub $local.defenseScore] $= ceil ( $target.adhoc.battle.pressure / 4 )
		[else]
			[sub $local.defenseScore] $= ceil ( $target.adhoc.battle.pressure / 2 )
		
		#[message] $> B: ${local.attackScore} vs ${local.defenseScore}
		
		[if $local.attackScore > $local.defenseScore]
			[gosub deal-damages]
				[args]
					faces: $= ( $performer.primary.missile.class = "ability" ) ? 6 10
					usage: missile
			
			[if $performer.actualUsages.missile.params.splash]
				[gosub splash-damages]
					[args]
						attack: $= $performer.actualUsages.missile.compound.attack + $performer.actualUsages.missile.params.splash.attack
						damages: $= $performer.actualUsages.missile.compound.damages + $performer.actualUsages.missile.params.splash.damages
						radius: $performer.actualUsages.missile.params.splash.radius
						missFlavour: $performer.actualUsages.missile.params.splash.missFlavour
						hitFlavour: $performer.actualUsages.missile.params.splash.hitFlavour
						criticalHitFlavour: $performer.actualUsages.missile.params.splash.criticalHitFlavour
						fatalHitFlavour: $performer.actualUsages.missile.params.splash.fatalHitFlavour
			
		[else]
			[fortune]
				- $> ${target.label//uc1} blocks ${performer.label}'s missile.
				- $> ${target.label//uc1} avoids ${performer.label}'s missile.
	
	
	
	[scene charge]
		[set $performer] $args.performer
		[set $target] $args.target
		
		[set $performer.adhoc.battle.speed] 10
		[set $performer.adhoc.battle.offensiveness] 1
		
		[if $battle.distance > 0]
			[set $performer.adhoc.battle.pressTarget] null
			[set $performer.adhoc.battle.pressValue] 0
			[message] $> ${performer.label//uc1} charges toward the opposing crew.
			[return]
		
		
		[set $local.attackScore] $= $performer.actualUsages.melee.compound.attack + ( 2 D 8 )
		[set $local.defenseScore] $= $target.actualUsages.melee.compound.defense + ( 2 D 8 )
		
		[set $performer.adhoc.battle.pressTarget] $target
		[set $performer.adhoc.battle.pressValue] 6
		
		[call battle/pressure] $performer
		[call battle/pressure] $target
		
		#[message] $> Pressure -- ${performer.adhoc.battle.pressure} / ${target.adhoc.battle.pressure}
		#[message] $> A: ${local.attackScore} vs ${local.defenseScore}
		
		# A charge is always offensive!
		[add $local.attackScore] 2
		# Charge is less sensible to the pressure
		[sub $local.attackScore] $= ceil ( $performer.adhoc.battle.pressure / 4 )
		
		[if $target.adhoc.battle.offensiveness > 0]
			[sub $local.defenseScore] 3
			[sub $local.defenseScore] $= ceil ( $target.adhoc.battle.pressure / 2 )
		[elseif $target.adhoc.battle.offensiveness < 0]
			[add $local.defenseScore] 2
			# Less sensible to the pressure when defending
			[sub $local.defenseScore] $= ceil ( $target.adhoc.battle.pressure / 4 )
		[else]
			[sub $local.defenseScore] $= ceil ( $target.adhoc.battle.pressure / 2 )
		
		#[message] $> B: ${local.attackScore} vs ${local.defenseScore}
		
		[message] $> ${performer.label//uc1} charges ${target.label}!
		
		[if $local.attackScore > $local.defenseScore]
			[gosub deal-damages]
			
			[if $battle.deadlyPush]
				[gosub deadly-push]
		[elseif ( $local.attackScore = $local.defenseScore ) && $battle.deadlyPush]
			[message] $> ${target.label//uc1} blocks ${performer.label}.
			[gosub deadly-push]
		[else]
			[fortune]
				- $> ${performer.label//uc1} misses ${target.label}.
				- $> ${target.label//uc1} blocks ${performer.label}.
				- $> ${target.label//uc1} avoids ${performer.label}.
	
	
	
	[scene deadly-push]
		[set $local.attackScore] $= ( ( max $performer.actual.stats.strength ( $performer.actual.stats.fighting - 3 ) ) + $battle.deadlyPush.bonus ) + ( 2 D 6 )
		[set $local.defenseScore] $= $target.actual.stats.strength + ( 2 D 6 )
		
		[sub $local.attackScore] $= $performer.adhoc.battle.pressure / 4
		[sub $local.defenseScore] $= $target.adhoc.battle.pressure / 4
		
		#[message] $> Attacker ${performer.label} offensiveness: ${performer.adhoc.battle.offensiveness}
		[if $performer.adhoc.battle.offensiveness > 0]
			[add $local.attackScore] 2
			#[message] Offensive: bonus!
		[elseif $performer.adhoc.battle.offensiveness < 0]
			[sub $local.attackScore] 3
			#[message] Defensive: malus!
		
		#[message] $> Defender ${target.label} offensiveness: ${target.adhoc.battle.offensiveness}
		[if $target.adhoc.battle.offensiveness > 0]
			[sub $local.defenseScore] 3
			#[message] Offensive: malus!
		[elseif $target.adhoc.battle.offensiveness < 0]
			[add $local.defenseScore] 2
			#[message] Defensive: bonus!
		
		[if $local.attackScore > $local.defenseScore]
			[set $target.status.hp] 0
			[apply-to $local.flavour] $battle.deadlyPush.flavour
			[message] $local.flavour
		
		
	
	
