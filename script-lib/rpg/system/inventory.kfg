
[[doctype spellcast/book]]

[system rpg:inventory]
	
	# Full inventory menu
	[fn here-inventory]
		[fake-next]
			[label] $> Inventory
			[button] inventory
			[on-trigger]
				[reset-here-actions]
				[gosub rpg:inventory/inventory-menu]
					[alt]
					[args]
						subject: $here.subject
						stack: $here.items


	
	[fn here-grab]
		[if $here.items is-empty?]
			[return]
		
		[map $here.items => $local.items] $= $this.label
		
		[if $local.items.length > 4]
			[set $local.items.length] 4
			[append $local.items] $> more
		
		[fake-next]
			[label] $> Grab items (${local.items}[enum:|$#|, $#| and $#])
			[on-trigger]
				[reset-here-actions]
				[gosub rpg:inventory/grab-menu]
					[alt]
					[args]
						subject: $here.subject
						stack: $here.items
	
	
	
	[scene inventory-menu]
		[init-sub]
			[set $subject] $args.subject
			[set $stack] $args.stack
		
		[filter $subject.equipped-item-list => $local.equipped-items] $= $this.class = "object"
		[filter $subject.items => $local.unequipped-items] $= $this.class = "object"
		
		[if ( ! $local.equipped-items.length ) && ( ! $local.unequipped-items.length )]
			[message] $> Empty inventory
			[return]
		
		[message] $> Inventory
		
		[next]
			[label] $> (Done)
			[button] close-alt
		
		[foreach $local.equipped-items => $local.index : $local.item]
			[next inventory-object]
				[args]
					index: $local.index
				[label] $> ${local.item.label} (${local.item.slot-type})
				[on-trigger]
					[set $item] $local.equipped-items[$args.index]
					[set $equipped] true
		
		[foreach $local.unequipped-items => $local.index : $local.item]
			[next inventory-object]
				[args]
					index: $local.index
				[label] $> ${local.item.label}
				[on-trigger]
					[set $item] $local.unequipped-items[$args.index]
					[set $equipped] false
	
	
	
	# Called by inventory-menu
	[scene inventory-object]
		
		[next inventory-menu]
			[label] $> (Done)
			[button] close-alt
		
		
		[fake-next]
			[label] $> Examine
			[on-trigger]
				[if $item.params.examine-flavor]
					[message] $item.params.examine-flavor
				[else]
					[message] $> There is nothing special.
		
		[if $equipped]
			[message]
				$> ^_${item.label//uc1}^ (equipped: ${item.slot-type})
			[next inventory-object]
				[label] $> Unequip ${item.label}
				[on-trigger]
					[set $equipped] false
					[unequip $subject]
						item: $item
			[if $stack]
				[next inventory-menu]
					[label] $> Unequip and drop ${item.label}
					[on-trigger]
						[emit rpg:drop-item => $local.cancel] $item
						[if ! $local.cancel]
							[set $equipped] false
							[unequip $subject]
								item: $item
							[drop $subject]
								item: $item
								stack: $stack
		[else]
			[message]
				$> ^_${item.label//uc1}^ (inventory)
			[next inventory-object]
				[label] $> Equip ${item.label}
				[on-trigger]
					[set $equipped] true
					[equip $subject]
						item: $item
			[if $stack]
				[next inventory-menu]
					[label] $> Drop ${item.label}
					[on-trigger]
						[emit rpg:drop-item => $local.cancel] $item
						[if ! $local.cancel]
							[drop $subject]
								item: $item
								stack: $stack
		
		[message]
			$>
			$> ${item.description//uc1/dash2space}
		
	
	
	[scene grab-menu]
		[init-sub]
			[set $subject] $args.subject
			[set $stack] $args.stack
			[set $first] true
		
		#[filter $args.stack => $local.items] $= $this.class = "object"
		
		[if ( $stack.length = 0 ) || $only-one]
			# Immediately exit
			[return]
		
		[if ( $stack.length = 1 ) && $first]
			# Immediately go to grab-object
			[set $first] false
			[set $only-one] true
			[set $item] $stack[0]
			[goto grab-object]
		
		[set $first] false
		
		[message] $> Grab what?
		
		[next]
			[label] $> (Done)
			[button] close-alt
		
		
		[foreach $stack => $local.index : $local.item]
			[next grab-object]
				[args]
					index: $local.index
				[label] $> ${local.item.label}
				[on-trigger]
					[set $item] $stack[$args.index]
		
	
	
	# Called by grab-menu
	[scene grab-object]
		
		[next grab-menu]
			[label] $> (Done)
			[button] close-alt
		
		
		[message]
			$> ^_${item.label//uc1}^:
			$>
			$> ${item.description//uc1/dash2space}
		
		[fake-next once]
			[label] $> Examine
			[on-trigger]
				[if $item.params.examine-flavor]
					[message] $item.params.examine-flavor
				[else]
					[message] $> There is nothing special.
		
		[next grab-menu]
			[label] $> Grab ${item.label}
			[on-trigger]
				[grab $subject]
					item: $item
					stack: $stack
		
	
	
	# Equip an ability as primary, or make any equipped item (ability or not) a primary
	[scene select-ability-primary]
		[set $subject] $args.subject
		[set $usage] $= ( $args.usage is-set? ) ? $args.usage true
		
		[message] $> Use what?
		
		[if $subject.primary[$usage]]
			[set $local.currentPrimary] $subject.primary[$usage]
			[set $local.abort-label] $> Keep using: ${local.currentPrimary.label} (${local.currentPrimary.class})
		[else]
			[set $local.abort-label] $> (Abort)
		
		[filter $subject.equipped-item-list => $local.items]
			$= ( $this.usages[$usage] is-set? ) && ( $this != $subject.primary[$usage] )
		
		[filter $subject.items => $local.moreItems]
			$= ( $this.class = "ability" ) && ( $this.usages[$usage] is-set? )
		
		[concat $local.items] $local.moreItems
		
		#[debug info] $subject.equipped-item-list
		#[debug info] $subject.items
		#[debug info] $local.items
		
		[next]
			[label] $local.abort-label
			[button] close-alt
		
		[foreach $local.items => $local.index : $local.item]
			[next]
				[args]
					index: $local.index
				[label] $> ${local.item.label//uc1} (${local.item.class})
				[on-trigger]
					[set $local.item] $local.items[$args.index]
					[if $local.item.class = "ability"]
						[unequip $subject]
							slot: ability
					[equip $subject]
						item: $local.item
						primary: $usage
	
	
	
	[scene select-ability-choose-primary]
		[set $subject] $args.subject
		
		[message] $> Which usage?
		
		[next]
			[label] $> (Abort)
			[button] close-alt
		
		[foreach $subject.usage-types => $local.usage]
			[next]
				[args]
					usage: $local.usage
				[label] $> ${local.usage//uc1/dash2space}
				[on-trigger]
					[gosub rpg:inventory/select-ability-primary]
						subject: $subject
						usage: $args.usage

	
	
	# Equip an object
	# Support a scheduler argument
	[scene equip-object]
		[set $subject] $args.subject
		[set $local.scheduler] $args.scheduler
		[set $slot] $= ( $args.slot is-set? ) ? $args.slot "hand"
		
		[message] $> Equip / unequip what?
		
		[set $local.equipped-items] $subject.equipped-items[$slot]
		[filter $subject.items => $local.unequipped-items] $= ( $this.class = "object" ) && ( $this.slot-type = $slot )
		
		#[debug info] $subject.equipped-item-list
		#[debug info] $subject.items
		#[debug info] $local.equipped-items
		
		[next]
			[label] $> (Abort)
			[button] close-alt
		
		[foreach $local.equipped-items => $local.index : $local.item]
			[next]
				[args]
					index: $local.index
				[label] $> Unequip ${local.item.label} (${local.item.class})
				[on-trigger]
					[set $local.item] $local.equipped-items[$args.index]
					
					[if $local.scheduler]
						[schedule-action $local.scheduler]
							subject: $subject
							action: unequip
							action-data:
								subject: $subject
								item: $local.item
							prepare-time: 5
							release-time: 5
							recover-time: 5
					[else]
						[unequip $subject]
							item: $local.item
					
					[return] true
		
		[foreach $local.unequipped-items => $local.index : $local.item]
			[next]
				[args]
					index: $local.index
				[label] $> Equip ${local.item.label} (${local.item.class})
				[on-trigger]
					[set $local.item] $local.unequipped-items[$args.index]
					
					[if $local.scheduler]
						[schedule-action $local.scheduler]
							subject: $subject
							action: equip
							action-data:
								subject: $subject
								item: $local.item
							prepare-time: 5
							release-time: 5
							recover-time: 5
					[else]
						[equip $subject]
							item: $local.item
					
					[return] true
	
	
	
	[scene equip-object-choose-slot]
		[set $subject] $args.subject
		[set $local.scheduler] $args.scheduler
		
		[message] $> Which slot?
		
		[next]
			[label] $> (Abort)
			[button] close-alt
		
		[foreach $subject.slots => $local.slot : $local.count]
			[next]
				[args]
					slot: $local.slot
				[label] $> ${local.slot//uc1/dash2space}
				[on-trigger]
					[gosub rpg:inventory/equip-object]
						subject: $subject
						slot: $args.slot
						scheduler: $local.scheduler


	
	
	
	
	# Deprecated (used by the fighting system)
	
	

	[scene drop-grab]
		[while ! $local.done]
			[gosub drop-grab-one => $local.done] $args
	
	
	
	[scene drop-grab-one]
		[next-style] inline
		
		[if ( $args.buy-price is-number? ) || ( $args.sell-price is-number? )]
			[if $args.subject.goods.cash is-empty?]
				[set $args.subject.goods.cash] 0
			[message] $> You have ^Y${args.subject.goods.cash}[$:cash-unit]^:.
		
		[next]
			[label] $> (Done)
			[button] close-alt
			[on-trigger]
				[return] true
		
		[next-group-break]
		[call grab-one] $args
		[next-group-break]
		[call drop-one] $args
		
	
	
	[fn grab-one]
		
		[foreach $args.stack => $local.index : $local.item]
			
			[if $local.item.class != "object"]
				[continue]
			
			[if ( $args.buy-price is-number? ) && ( $local.item.own-stats.price is-number? )]
				[set $local.verb] buy
				[set $local.price] $= ceil ( $local.item.own-stats.price * $args.buy-price )
				[set $local.price-string] $> (${local.price}[$:cash-unit])
			[else]
				[set $local.verb] grab
				[set $local.price] 0
				[set $local.price-string] ""
			
			[next]
				[args]
					subject: $args.subject
					stack: $args.stack
					item: $local.item
					price: $local.price
				[label] $> ${local.verb//uc1} ${local.item.label//uc1} ${local.price-string}
				[on-trigger]
					[if $args.subject.goods.cash >= $args.price]
						[sub $args.subject.goods.cash] $args.price
						[grab $args.subject]
							item: $args.item
							stack: $args.stack
					[else]
						[message] $> Not enough cash!
		
	
	
	[fn drop-one]
		
		[foreach $args.subject.items => $local.index : $local.item]
			[if $local.item.class != "object"]
				[continue]
			
			[if ( $args.sell-price is-number? ) && ( $local.item.own-stats.price is-number? )]
				[set $local.verb] sell
				[set $local.price] $= floor ( $local.item.own-stats.price * $args.sell-price )
				[set $local.price-string] $> (${local.price}[$:cash-unit])
			[else]
				[set $local.verb] drop
				[set $local.price] 0
				[set $local.price-string] ""
			
			[next]
				[args]
					subject: $args.subject
					stack: $args.stack
					item: $local.item
					price: $local.price
				[label] $> ${local.verb//uc1} ${local.item.label//uc1} ${local.price-string}
				[on-trigger]
					[add $args.subject.goods.cash] $args.price
					[drop $args.subject]
						item: $args.item
						stack: $args.stack
		

