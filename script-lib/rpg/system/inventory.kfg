
[[doctype adventurer]]

[system inventory]
	
	# Equip an ability as primary, or make any equipped item (ability or not) a primary
	[scene select-ability-primary]
		[set $performer] $args.performer
		[set $usage] $= ( $args.usage is-set? ) ? $args.usage true
		
		[message] Use what?
		
		[if $performer.primary[$usage]]
			[set $local.currentPrimary] $performer.primary[$usage]
			[set $local.abortLabel] $> Keep using: ${local.currentPrimary.label} (${local.currentPrimary.class})
		[else]
			[set $local.abortLabel] $> (Abort)
		
		[filter $performer.equippedItemList => $local.items] $= ( $this.usages[$usage] is-set? ) && ( $this != $performer.primary[$usage] )
		[filter $performer.items => $local.moreItems] $= ( $this.class = "ability" ) && ( $this.usages[$usage] is-set? )
		
		[concat $local.items] $local.moreItems
		
		#[debug info] $performer.equippedItemList
		#[debug info] $performer.items
		#[debug info] $local.items
		
		[next] $local.abortLabel
		
		[foreach $local.items => $local.index : $local.item]
			[next]
				[args]
					index: $local.index
				[label] $> ${local.item.label//uc1} (${local.item.class})
				[on-trigger]
					[set $local.item] $local.items[$args.index]
					[if $local.item.class = "ability"]
						[unequip $performer]
							slot: ability
					[equip $performer]
						item: $local.item
						primary: $usage
	
	
	
	[scene select-ability-choose-primary]
		[set $performer] $args.performer
		
		[message] Which usage?
		
		[next] $> (Abort)
		
		[foreach $performer.usageTypes => $local.usage]
			[next]
				[args]
					usage: $local.usage
				[label] $> ${local.usage//uc1/dash2space}
				[on-trigger]
					[gosub inventory/select-ability-primary]
						performer: $performer
						usage: $args.usage

	
	
	# Equip an object
	[scene equip-object]
		[set $performer] $args.performer
		[set $slot] $= ( $args.slot is-set? ) ? $args.slot "hand"
		
		[message] Equip / unequip what?
		
		[set $local.unequippedItems] $performer.equippedItems[$slot]
		[filter $performer.items => $local.equippedItems] $= ( $this.class = "object" ) && ( $this.slotType = $slot )
		
		#[debug info] $performer.equippedItemList
		#[debug info] $performer.items
		#[debug info] $local.equippedItems
		
		[next] $> (Abort)
		
		[foreach $local.unequippedItems => $local.index : $local.item]
			[next]
				[args]
					index: $local.index
				[label] $> Unequip ${local.item.label} (${local.item.class})
				[on-trigger]
					[set $local.item] $local.unequippedItems[$args.index]
					[unequip $performer]
						item: $local.item
					[return] true
		
		[foreach $local.equippedItems => $local.index : $local.item]
			[next]
				[args]
					index: $local.index
				[label] $> Equip ${local.item.label} (${local.item.class})
				[on-trigger]
					[set $local.item] $local.equippedItems[$args.index]
					[equip $performer]
						item: $local.item
					[return] true
	
	
	
	[scene equip-object-choose-slot]
		[set $performer] $args.performer
		
		[message] Which slot?
		
		[next] $> (Abort)
		
		[foreach $performer.slots => $local.slot : $local.count]
			[next]
				[args]
					slot: $local.slot
				[label] $> ${local.slot//uc1/dash2space}
				[on-trigger]
					[gosub inventory/equip-object]
						performer: $performer
						slot: $args.slot



	[scene drop-grab]
		[while ! $local.done]
			[gosub drop-grab-one => $local.done] $args
	
	
	
	[scene drop-grab-one]
		[if ( $args.buy-price is-number? ) || ( $args.sell-price is-number? )]
			[if $args.performer.goods.gp is-empty?]
				[set $args.performer.goods.gp] 0
			[message] $> You have ^Y${args.performer.goods.gp}^ GP.
		
		[next]
			[label] $> (Done)
			[on-trigger]
				[return] true
		[call grab-one] $args
		[call drop-one] $args
		
	
	
	[fn grab-one]
		
		[foreach $args.stack => $local.index : $local.item]
			
			[if $local.item.class != "object"]
				[continue]
			
			[if ( $args.buy-price is-number? ) && ( $local.item.ownStats.price is-number? )]
				[set $local.verb] buy
				[set $local.price] $= ceil ( $local.item.ownStats.price * $args.buy-price )
				[set $local.price-string] $> (${local.price} GP)
			[else]
				[set $local.verb] grab
				[set $local.price] 0
				[set $local.price-string] ""
			
			[next]
				[args]
					performer: $args.performer
					stack: $args.stack
					item: $local.item
					price: $local.price
				[label] $> ${local.verb//uc1} ${local.item.label//uc1} ${local.price-string}
				[on-trigger]
					[if $args.performer.goods.gp >= $args.price]
						[sub $args.performer.goods.gp] $args.price
						[grab $args.performer]
							item: $args.item
							stack: $args.stack
					[else]
						[message] $> Not enough GP!
		
	
	
	[fn drop-one]
		
		[foreach $args.performer.items => $local.index : $local.item]
			[if $local.item.class != "object"]
				[continue]
			
			[if ( $args.sell-price is-number? ) && ( $local.item.ownStats.price is-number? )]
				[set $local.verb] sell
				[set $local.price] $= floor ( $local.item.ownStats.price * $args.sell-price )
				[set $local.price-string] $> (${local.price} GP)
			[else]
				[set $local.verb] drop
				[set $local.price] 0
				[set $local.price-string] ""
			
			[next]
				[args]
					performer: $args.performer
					stack: $args.stack
					item: $local.item
					price: $local.price
				[label] $> ${local.verb//uc1} ${local.item.label//uc1} ${local.price-string}
				[on-trigger]
					[add $args.performer.goods.gp] $args.price
					[drop $args.performer]
						item: $args.item
						stack: $args.stack
		


