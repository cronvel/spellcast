
[[doctype adventurer]]

[chapter battle]
	
	[scene init]
		[set $battle] <Object>
		
		[set $battle.foes] <Array>
		[set $battle.turnIndex] 0
		[set $battle.round] 0
		[set $battle.turns] <Array>
		[set $battle.distance] $= ( $args.distance is-set? ) ? ( floor ( abs $args.distance ) 2 ) 0
		
		[foreach $args.foes => $local.index : $local.foe]
			[if ! ( $local.foe is-entity? )]
				[create-entity $local.foe] $local.foe
			[set $battle.foes[$local.index]] $local.foe
			[append $battle.turns] $local.foe
			[set $local.foe.adhoc.battle]
				side: foes
				cooldown: 0
				offensiveness: $= ( $local.foe.stances.offensiveness is-set? ) ? $local.foe.stances.offensiveness 0
				pressTarget: null
				pressure: 0
				speed: 0
			
		[foreach $args.allies => $local.index : $local.ally]
			[if ! ( $local.ally is-entity? )]
				[create-entity $local.ally] $local.ally
			[set $battle.allies[$local.index]] $local.ally
			[append $battle.turns] $local.ally
			[set $local.ally.adhoc.battle]
				side: allies
				cooldown: 0
				offensiveness: $= ( $local.ally.stances.offensiveness is-set? ) ? $local.ally.stances.offensiveness 0
				pressTarget: null
				pressure: 0
				speed: 0
			
		[filter $battle.foes => $battle.aliveFoes] $= $this.status.hp > 0
		[filter $battle.allies => $battle.aliveAllies] $= $this.status.hp > 0
		
		#[debug info] $battle.allies
		#[debug info] $battle.foes
		#[debug info] $battle.aliveFoes
		#[debug info] $battle.turns
		
		[set $battle.deadlyPush] $args.deadlyPush
		
		[next initiative]
	
	
	
	[scene initiative]
		[foreach $battle.turns => $local.entity]
			[set $local.entity.adhoc.battle.initiativeScore] $= $local.entity.actual.stats.fighting + ( 2 D 8 )
		
			[if $local.entity.adhoc.battle.offensiveness > 0]
				[add $local.entity.adhoc.battle.initiativeScore] 2
			[elseif $local.entity.adhoc.battle.offensiveness < 0]
				[sub $local.entity.adhoc.battle.initiativeScore] 3
		
		#[sort $battle.turns] $= - $this.adhoc.battle.initiativeScore
		[sort $battle.turns] $= $this.right.adhoc.battle.initiativeScore - $this.left.adhoc.battle.initiativeScore
		
		#[debug info] $battle.turns
		[message] $> ^yThe distance between opponents is ${battle.distance} ${battle.distance}[n?step|steps].
		[message] $> ${battle.turns[0].label//uc1} takes the initiative.
		[goto new-turn]
		
	
	
	[scene new-turn]
		[set $battle.entityTurn] $= $battle.turns[$battle.turnIndex]
		
		[if $battle.entityTurn.status.hp <= 0]
			[goto end-turn]
		
		[if $battle.entityTurn.adhoc.battle.cooldown > 0]
			[dec $battle.entityTurn.adhoc.battle.cooldown]
			[goto end-turn]
		
		[gosub battle-lines]
		
		[if $battle.entityTurn.npc]
			[goto npc-turn]
		[else]
			[goto pc-turn]
	
	
	
	[scene end-turn]
		[set $battle.turnIndex] $= ( $battle.turnIndex + 1 ) % $battle.turns.length
		
		[if $battle.turnIndex = 0]
			[call battle/new-round]
		
		[filter $battle.foes => $battle.aliveFoes] $= $this.status.hp > 0
		[filter $battle.allies => $battle.aliveAllies] $= $this.status.hp > 0
		
		[if ! $battle.aliveAllies.length]
			[goto lost]
		[elseif ! $battle.aliveFoes.length]
			[goto win]
		
		[goto new-turn]
	
	
	
	[fn battle/new-round]
		[inc $battle.round]
		
		# Manage distance
		[if $battle.distance > 0]
			[map $battle.aliveAllies => $local.alliesSpeed] $this.adhoc.battle.speed
			[map $battle.aliveFoes => $local.foesSpeed] $this.adhoc.battle.speed
			
			[set $battle.distance] $= max 0 ( trunc ( $battle.distance - ( avg $local.alliesSpeed ) - ( avg $local.foesSpeed ) ) 2 )
			
			[message] $> ^yThe remaining distance between opponents is ${battle.distance} ${battle.distance}[n?step|steps].
			[if $battle.distance = 0]
				[message] $> ^yThe two opposing crews join together and clash.
		
	
	
	[fn battle/all-pressure]
		[foreach $battle.aliveEntities => $local.entity]
			[call battle/pressure] $local.entity
		
	[fn battle/pressure]
		[reduce $battle.aliveEntities , 0 => $args.adhoc.battle.pressure] $= $this.previous + ( ( $this.current.adhoc.battle.pressTarget = $args ) ? $this.current.adhoc.battle.pressValue 0 )
		# Pressure has a max level, because when the target is saturated,
		# extra opponents are not able to reach the target properly:
		# both the target and its opponents get some malus, therefore the pressure is capped to 18 (4 charging opponents)
		[set $args.adhoc.battle.pressure] $= min ( max 0 ( $args.adhoc.battle.pressure - 6 ) ) 18
		
		
		
	[scene battle-lines]
		
		[filter $battle.aliveFoes => $front] $= $this.adhoc.battle.offensiveness > 0
		[filter $battle.aliveFoes => $middle] $= $this.adhoc.battle.offensiveness = 0
		[filter $battle.aliveFoes => $back] $= $this.adhoc.battle.offensiveness < 0
		
		[set $offset] $= ceil ( ( 1 - $front.length ) / 2 )
		[foreach $front => $index : $entity]
			[set $entity.adhoc.battle.position]
				x: $= $battle.distance / 2
				y: $= $index + $offset
		
		[set $offset] $= ceil ( ( 1 - $middle.length ) / 2 )
		[foreach $middle => $index : $entity]
			[set $entity.adhoc.battle.position]
				x: $= ( $battle.distance / 2 ) + 1
				y: $= $index + $offset
		
		[set $offset] $= ceil ( ( 1 - $back.length ) / 2 )
		[foreach $back => $index : $entity]
			[set $entity.adhoc.battle.position]
				x: $= ( $battle.distance / 2 ) + 2
				y: $= $index + $offset
		
		#[sort $battle.aliveFoes] $= $this.adhoc.battle.position.y + ( $this.adhoc.battle.position.x / 1000 )
		[sort $battle.aliveFoes] $= ( $this.left.adhoc.battle.position.y + ( $this.left.adhoc.battle.position.x / 1000 ) ) - ( $this.right.adhoc.battle.position.y + ( $this.right.adhoc.battle.position.x / 1000 ) )
		
		#[map $battle.aliveFoes => $tmp] $this.adhoc.battle
		#[debug info] $tmp
		
		# Same for allies
		
		[filter $battle.aliveAllies => $front] $= $this.adhoc.battle.offensiveness > 0
		[filter $battle.aliveAllies => $middle] $= $this.adhoc.battle.offensiveness = 0
		[filter $battle.aliveAllies => $back] $= $this.adhoc.battle.offensiveness < 0
		
		[set $offset] $= ceil ( ( 1 - $front.length ) / 2 )
		[foreach $front => $index : $entity]
			[set $entity.adhoc.battle.position]
				x: $= - ( $battle.distance / 2 )
				y: $= $index + $offset
		
		[set $offset] $= ceil ( ( 1 - $middle.length ) / 2 )
		[foreach $middle => $index : $entity]
			[set $entity.adhoc.battle.position]
				x: $= ( - ( $battle.distance / 2 ) ) - 1
				y: $= $index + $offset
		
		[set $offset] $= ceil ( ( 1 - $back.length ) / 2 )
		[foreach $back => $index : $entity]
			[set $entity.adhoc.battle.position]
				x: $= ( - ( $battle.distance / 2 ) ) - 2
				y: $= $index + $offset
			
		#[sort $battle.aliveAllies] $= $this.adhoc.battle.position.y + ( $this.adhoc.battle.position.x / 1000 )
		[sort $battle.aliveAllies] $= ( $this.left.adhoc.battle.position.y + ( $this.left.adhoc.battle.position.x / 1000 ) ) - ( $this.right.adhoc.battle.position.y + ( $this.right.adhoc.battle.position.x / 1000 ) )
		
		[set $battle.aliveEntities] <Array>
		[concat $battle.aliveEntities] $battle.aliveFoes
		[concat $battle.aliveEntities] $battle.aliveAllies
		
		
	
	[scene npc-turn]
		
		[gosub npc-targeting]
		
		[set $attacker] $battle.entityTurn
		
		[if $attacker.params.battleCry && ( ( random ) <= $attacker.params.battleCry )]
			[if $attacker.params.battleCryFlavour]
				[apply-to $local.flavour] $= random-element $attacker.params.battleCryFlavour
				[message] $local.flavour
			[else]
				[message] $> ${attacker.label//uc1} shouts!
		
		
		[if $attacker.params.charge && ( ( random ) <= $attacker.params.charge )]
			[gosub charge]
				[args]
					attacker: $attacker
					defender: $battle.target
			[goto end-turn]
		
		[gosub melee]
			[args]
				attacker: $attacker
				defender: $battle.target
		
		[goto end-turn]
		
	
	
	[scene pc-turn]
		[if $battle.distance = 0]
			[set $local.meleeLabel] attack
		[else]
			[set $local.meleeLabel] march
		
		[next pc-melee]
			[label] $> ${local.meleeLabel//uc1}
			[on-trigger]
				[set $battle.entityTurn.adhoc.battle.offensiveness] 0
		
		[next pc-melee]
			[label] $> ${local.meleeLabel//uc1} boldly
			[on-trigger]
				[set $battle.entityTurn.adhoc.battle.offensiveness] 1
		
		[next pc-melee]
			[label] $> ${local.meleeLabel//uc1} cautiously
			[on-trigger]
				[set $battle.entityTurn.adhoc.battle.offensiveness] -1
		
		[next pc-charge]
			[label] Charge!
	
		[if $battle.distance > 0]
			[next pc-missile]
				[label] $> Shoot
		
		[next pc-fireball]
			[label] Fireball
	
	
	
	[scene npc-targeting]
		
		[if $battle.entityTurn.adhoc.battle.side = "allies"]
			[set $local.enemies] $battle.aliveFoes
		[else]
			[set $local.enemies] $battle.aliveAllies
		
		[set $local.index] $= random ( $local.enemies.length - 1 )
		[set $battle.target] $local.enemies[$local.index]
	
	
	
	[scene pc-targeting]
		[set $local.count] 0
		
		[if $battle.entityTurn.adhoc.battle.side = "allies"]
			[set $local.enemies] $battle.aliveFoes
		[else]
			[set $local.enemies] $battle.aliveAllies
		
		[if $local.enemies.length <= 1]
			[set $battle.target] $local.enemies[0]
			[return]
		
		[message] Target?
		
		[foreach $local.enemies => $local.index : $local.entity]
			[if $local.entity.adhoc.battle.offensiveness > 0]
				[set $local.position] "←"
			[elseif $local.entity.adhoc.battle.offensiveness < 0]
				[set $local.position] "→    "
			[else]
				[set $local.position] "   "
			
			[next]
				[args]
					index: $local.index
				[label] $> ${local.position} ${local.entity.label//uc1}
				[on-trigger]
					[set $battle.target] $local.enemies[$args.index]
	
	
	
	[scene pc-melee]
		[if $battle.distance = 0]
			[gosub pc-targeting]
		[gosub melee]
			[args]
				attacker: $battle.entityTurn
				defender: $battle.target
		[goto end-turn]
	
	
	
	[scene pc-missile]
		[if $battle.distance > 0]
			[gosub pc-targeting]
		[gosub missile]
			[args]
				attacker: $battle.entityTurn
				defender: $battle.target
		[goto end-turn]
	
	
	
	[scene pc-charge]
		[if $battle.distance = 0]
			[gosub pc-targeting]
		[gosub charge]
			[args]
				attacker: $battle.entityTurn
				defender: $battle.target
		[goto end-turn]
	
	
	
	[scene pc-fireball]
		[gosub pc-targeting]
		[gosub fireball]
			[args]
				attacker: $battle.entityTurn
				defender: $battle.target
		[goto end-turn]
	
	
	
	[scene win]
		[message] $> ${battle.allies[0].label//uc1} win the battle.
		[set $local.xpReward] 0
		
		[foreach $battle.foes => $local.entity]
			[add $local.xpReward] $local.entity.params.xpReward
		
		[set $local.xpReward] $= ceil ( $local.xpReward / $battle.allies.length )
		
		[foreach $battle.allies => $local.index : $local.entity]
			[add $local.entity.status.xp] $local.xpReward
		
		[message] $> You gain ${local.xpReward} xp (=${battle.allies[0].status.xp}).
	
	
	
	[scene lost]
		[message] $> ${battle.allies[0].label//uc1} died on the battlefield.
		[lost]

	
	
	#melee damage
	[scene deal-damages]
		[if $args.defender]
			[set $defender] $args.defender
		
		[set $local.usage] $= $args.usage ? $args.usage "melee"
		[set $local.faces] $= $args.faces ? $args.faces 6
		
		# Damage level
		[if $args.damages is-real?]
			[set $local.attackScore] $= $args.damages + ( 2 D $local.faces )
		[else]
			[set $local.attackScore] $= $attacker.actualUsages[$local.usage].compound.damages + ( 2 D $local.faces )
			
			# Attacker offensiveness is used only when not using fixed damage base
			[if $attacker.adhoc.battle.offensiveness > 0]
				[add $local.attackScore] 2
			[elseif $attacker.adhoc.battle.offensiveness < 0]
				[sub $local.attackScore] 3
			
		
		[set $local.defenseScore] $= $defender.actual.stats.resilience + ( 2 D 6 )
		
		# Always used?
		[if $defender.adhoc.battle.offensiveness > 0]
			[sub $local.defenseScore] 3
		[elseif $defender.adhoc.battle.offensiveness < 0]
			[add $local.defenseScore] 2
		
		#[message] $> ${local.attackScore} vs ${local.defenseScore}
		
		[set $damages] $= ( ( $local.attackScore - $local.defenseScore ) + ( random ) ) - 0.5
		
		
		[if $args.bonus is-real?]
			[add $damages] $args.bonus
		
		#[message] $> damages: ${damages}
		
		# This is the magic formula that transform damage levels into real hit point loss, with the correct feeling
		# damage-level = +20 is needed for an instant death
		[set $damages] $= round ( 10 * ( 2 ^ ( $damages / 6 ) ) )
		
		#[message] $> damages: ${damages}
		
		[sub $defender.status.hp] $damages
		
		[if $damages >= 100]
			[if $args.fatalHitFlavour is-set?]
				[apply-to $local.flavour] $args.fatalHitFlavour
			[elseif $args.criticalHitFlavour is-set?]
				[apply-to $local.flavour] $args.criticalHitFlavour
			[elseif $args.hitFlavour is-set?]
				[apply-to $local.flavour] $args.hitFlavour
			[elseif $attacker.actualUsages[$local.usage].params.fatalHitFlavour is-set?]
				[apply-to $local.flavour] $attacker.actualUsages[$local.usage].params.fatalHitFlavour
			[elseif $attacker.actualUsages[$local.usage].params.criticalHitFlavour is-set?]
				[apply-to $local.flavour] $attacker.actualUsages[$local.usage].params.criticalHitFlavour
			[elseif $attacker.actualUsages[$local.usage].params.hitFlavour is-set?]
				[apply-to $local.flavour] $attacker.actualUsages[$local.usage].params.hitFlavour
			[else]
				[set $local.flavour] $> ^r${attacker.label//uc1} deadly hits ${defender.label} for ${damages} hp.
		[elseif $damages >= 25]
			[if $args.criticalHitFlavour is-set?]
				[apply-to $local.flavour] $args.criticalHitFlavour
			[elseif $args.hitFlavour is-set?]
				[apply-to $local.flavour] $args.hitFlavour
			[elseif $attacker.actualUsages[$local.usage].params.criticalHitFlavour is-set?]
				[apply-to $local.flavour] $attacker.actualUsages[$local.usage].params.criticalHitFlavour
			[elseif $attacker.actualUsages[$local.usage].params.hitFlavour is-set?]
				[apply-to $local.flavour] $attacker.actualUsages[$local.usage].params.hitFlavour
			[else]
				[set $local.flavour] $> ^r${attacker.label//uc1} critically hits ${defender.label} for ${damages} hp.
		[else]
			[if $args.hitFlavour is-set?]
				[apply-to $local.flavour] $args.hitFlavour
			[elseif $attacker.actualUsages[$local.usage].params.hitFlavour is-set?]
				[apply-to $local.flavour] $attacker.actualUsages[$local.usage].params.hitFlavour
			[else]
				[set $local.flavour] $> ^r${attacker.label//uc1} hits ${defender.label} for ${damages} hp.
		
		[message] $local.flavour
		
		[if $defender.status.hp <= 0]
			[message] $> ^R^+${defender.label//uc1} is dead.
	
	
	
	[scene splash-damages]
		[set $aliveEntities] <Array>
		[concat $aliveEntities] $battle.aliveFoes
		[concat $aliveEntities] $battle.aliveAllies
		[set $pos] $defender.adhoc.battle.position
		
		[foreach $aliveEntities => $target]
			
			[if ( $target = $defender ) || ( $target = $attacker )]
				[continue]
			
			[set $targetPos] $target.adhoc.battle.position
			
			[if ( hypot ( $targetPos.x - $pos.x ) ( $targetPos.y - $pos.y ) ) <= $args.radius]
				
				[set $local.attackScore] $= $args.attack + ( 2 D 8 )
# Or use $target.actualUsages.missile.compound.defense?
				[set $local.defenseScore] $= $target.actualUsages.melee.compound.defense + ( 2 D 8 )
				
				[call battle/pressure] $target
				
				[if $target.adhoc.battle.offensiveness > 0]
					[sub $local.defenseScore] 3
					[sub $local.defenseScore] $= ceil ( $target.adhoc.battle.pressure / 2 )
				[elseif $target.adhoc.battle.offensiveness < 0]
					[add $local.defenseScore] 2
					# Less sensible to the pressure when defending
					[sub $local.defenseScore] $= ceil ( $target.adhoc.battle.pressure / 4 )
				[else]
					[sub $local.defenseScore] $= ceil ( $target.adhoc.battle.pressure / 2 )
				
				[if $local.attackScore > $local.defenseScore]
					[gosub deal-damages]
						[args]
							defender: $target
							hitFlavour: $args.hitFlavour
							criticalHitFlavour: $args.criticalHitFlavour
							fatalHitFlavour: $args.fatalHitFlavour
							damages: $args.damages
				
				[else]
					[if $args.missFlavour]
						[apply-to $flavour] $args.missFlavour
						[message] $flavour
			
	
	
	[scene melee]
		[set $attacker] $args.attacker
		[set $defender] $args.defender
		
		[set $attacker.adhoc.battle.speed] $= $attacker.adhoc.battle.offensiveness ??? 2 4 6
		
		[if $battle.distance > 0]
			[set $attacker.adhoc.battle.pressTarget] null
			[set $attacker.adhoc.battle.pressValue] 0
			
			[if $attacker.adhoc.battle.offensiveness > 0]
				[message] $> ${attacker.label//uc1} runs toward the opposing crew.
			[elseif $attacker.adhoc.battle.offensiveness < 0]
				[message] $> ${attacker.label//uc1} walk cautiously toward the opposing crew.
			[else]
				[message] $> ${attacker.label//uc1} marches toward the opposing crew.
			
			[return]
			
		
		[set $local.attackScore] $= $attacker.actualUsages.melee.compound.attack + ( 2 D 8 )
		[set $local.defenseScore] $= $defender.actualUsages.melee.compound.defense + ( 2 D 8 )
		
		[set $attacker.adhoc.battle.pressTarget] $defender
		[set $attacker.adhoc.battle.pressValue] $= $attacker.adhoc.battle.offensiveness ??? 3 4 6
		
		[call battle/pressure] $attacker
		[call battle/pressure] $defender
		
		#[message] $> Pressure -- ${attacker.adhoc.battle.pressure} / ${defender.adhoc.battle.pressure}
		#[message] $> A: ${local.attackScore} vs ${local.defenseScore}
		
		[if $attacker.adhoc.battle.offensiveness > 0]
			[add $local.attackScore] 2
			# Less sensible to the pressure when attacking
			[sub $local.attackScore] $= ceil ( $attacker.adhoc.battle.pressure / 4 )
		[elseif $attacker.adhoc.battle.offensiveness < 0]
			[sub $local.attackScore] 3
			[sub $local.attackScore] $= ceil ( $attacker.adhoc.battle.pressure / 2 )
		[else]
			[sub $local.attackScore] $= ceil ( $attacker.adhoc.battle.pressure / 2 )
		
		[if $defender.adhoc.battle.offensiveness > 0]
			[sub $local.defenseScore] 3
			[sub $local.defenseScore] $= ceil ( $defender.adhoc.battle.pressure / 2 )
		[elseif $defender.adhoc.battle.offensiveness < 0]
			[add $local.defenseScore] 2
			# Less sensible to the pressure when defending
			[sub $local.defenseScore] $= ceil ( $defender.adhoc.battle.pressure / 4 )
		[else]
			[sub $local.defenseScore] $= ceil ( $defender.adhoc.battle.pressure / 2 )
		
		#[message] $> B: ${local.attackScore} vs ${local.defenseScore}
		
		[if $local.attackScore > $local.defenseScore]
			[gosub deal-damages]
			
		[else]
			[fortune]
				- $> ${attacker.label//uc1} misses ${defender.label}.
				- $> ${defender.label//uc1} blocks ${attacker.label}.
				- $> ${defender.label//uc1} avoids ${attacker.label}.
	
	
	
	[scene missile]
		[set $attacker] $args.attacker
		[set $defender] $args.defender
		
		# Temp:
		[set $missile] arrow
		
		[set $attacker.adhoc.battle.speed] 0
		[set $attacker.adhoc.battle.offensiveness] -1
		[if $battle.distance = 0]
			# Should never happen
			[set $attacker.adhoc.battle.pressTarget] null
			[set $attacker.adhoc.battle.pressValue] 0
			[message] $> ${attacker.label//uc1} is too close to use that weapon.
			[return]
			
		
		[set $attacker.adhoc.battle.pressTarget] $defender
		[set $attacker.adhoc.battle.pressValue] 4
		
		[call battle/pressure] $attacker
		[call battle/pressure] $defender
		
		[set $local.aimingScore] $= $attacker.actualUsages.missile.compound.aiming + ( 2 D 12 )
		[set $local.coverScore] $= ( $battle.distance / 2 ) + ( abs $defender.adhoc.battle.speed ) + ( 2 D 12 )
		
		#[message] $> Aiming A: ${local.aimingScore} vs ${local.coverScore}
		#[message] $> Pressure: ${attacker.adhoc.battle.pressure}
		
		[sub $local.aimingScore] $= ceil ( $attacker.adhoc.battle.pressure / 2 )
		
		#[message] $> Aiming B: ${local.aimingScore} vs ${local.coverScore}
		
		[if $local.aimingScore < $local.coverScore]
			[message] $> ${attacker.label//uc1} misses ${defender.label}.
			[return]
		
		#[message] $> Cover: ${defender.actualUsages.missile.compound.cover}
		#[debug info] $defender.equippedItems.hand[0]
		#[debug info] $defender.actualUsages.missile
		
		[add $local.coverScore] $defender.actualUsages.missile.compound.cover
		
		[if $local.aimingScore < $local.coverScore]
			[if $defender.actualUsages.missile.params.coverFlavour is-set?]
				[apply-to $local.flavour] $defender.actualUsages.missile.params.coverFlavour
				[message] $local.flavour
			[else]
				[message] $> ${attacker.label//uc1} misses ${defender.label}.
			[return]
		
		[set $local.attackScore] $= $attacker.actualUsages.missile.compound.attack + ( 2 D 12 )
		[set $local.defenseScore] $= $defender.actualUsages.missile.compound.defense + ( 2 D 12 )
		
		#[message] $> Pressure -- ${attacker.adhoc.battle.pressure} / ${defender.adhoc.battle.pressure}
		#[message] $> A: ${local.attackScore} vs ${local.defenseScore}
		
		# Attack score of missile do not depend much on the character but on the weapon
		#[sub $local.attackScore] $= ceil ( $attacker.adhoc.battle.pressure / 2 )
		
		[if $defender.adhoc.battle.offensiveness > 0]
			[sub $local.defenseScore] 3
			[sub $local.defenseScore] $= ceil ( $defender.adhoc.battle.pressure / 2 )
		[elseif $defender.adhoc.battle.offensiveness < 0]
			[add $local.defenseScore] 2
			# Less sensible to the pressure when defending
			[sub $local.defenseScore] $= ceil ( $defender.adhoc.battle.pressure / 4 )
		[else]
			[sub $local.defenseScore] $= ceil ( $defender.adhoc.battle.pressure / 2 )
		
		#[message] $> B: ${local.attackScore} vs ${local.defenseScore}
		
		[if $local.attackScore > $local.defenseScore]
			[gosub deal-damages]
				[args]
					faces: 10
					usage: missile
			
		[else]
			[fortune]
				- $> ${defender.label//uc1} blocks ${attacker.label}'s missile.
				- $> ${defender.label//uc1} avoids ${attacker.label}'s missile.
	
	
	
	[scene charge]
		[set $attacker] $args.attacker
		[set $defender] $args.defender
		
		[set $attacker.adhoc.battle.speed] 10
		[set $attacker.adhoc.battle.offensiveness] 1
		
		[if $battle.distance > 0]
			[set $attacker.adhoc.battle.pressTarget] null
			[set $attacker.adhoc.battle.pressValue] 0
			[message] $> ${attacker.label//uc1} charges toward the opposing crew.
			[return]
		
		
		[set $local.attackScore] $= $attacker.actualUsages.melee.compound.attack + ( 2 D 8 )
		[set $local.defenseScore] $= $defender.actualUsages.melee.compound.defense + ( 2 D 8 )
		
		[set $attacker.adhoc.battle.pressTarget] $defender
		[set $attacker.adhoc.battle.pressValue] 6
		
		[call battle/pressure] $attacker
		[call battle/pressure] $defender
		
		#[message] $> Pressure -- ${attacker.adhoc.battle.pressure} / ${defender.adhoc.battle.pressure}
		#[message] $> A: ${local.attackScore} vs ${local.defenseScore}
		
		# A charge is always offensive!
		[add $local.attackScore] 2
		# Charge is less sensible to the pressure
		[sub $local.attackScore] $= ceil ( $attacker.adhoc.battle.pressure / 4 )
		
		[if $defender.adhoc.battle.offensiveness > 0]
			[sub $local.defenseScore] 3
			[sub $local.defenseScore] $= ceil ( $defender.adhoc.battle.pressure / 2 )
		[elseif $defender.adhoc.battle.offensiveness < 0]
			[add $local.defenseScore] 2
			# Less sensible to the pressure when defending
			[sub $local.defenseScore] $= ceil ( $defender.adhoc.battle.pressure / 4 )
		[else]
			[sub $local.defenseScore] $= ceil ( $defender.adhoc.battle.pressure / 2 )
		
		#[message] $> B: ${local.attackScore} vs ${local.defenseScore}
		
		[message] $> ${attacker.label//uc1} charges ${defender.label}!
		
		[if $local.attackScore > $local.defenseScore]
			[gosub deal-damages]
			
			[if $battle.deadlyPush]
				[gosub deadly-push]
		[elseif ( $local.attackScore = $local.defenseScore ) && $battle.deadlyPush]
			[message] $> ${defender.label//uc1} blocks ${attacker.label}.
			[gosub deadly-push]
		[else]
			[fortune]
				- $> ${attacker.label//uc1} misses ${defender.label}.
				- $> ${defender.label//uc1} blocks ${attacker.label}.
				- $> ${defender.label//uc1} avoids ${attacker.label}.
	
	
	
	[scene fireball]
		[set $attacker] $args.attacker
		[set $defender] $args.defender
		
		[set $attacker.adhoc.battle.speed] 0
		[set $attacker.adhoc.battle.offensiveness] -1
		
		[sub $attacker.status.mana] 6
		[message] $> mana: ${attacker.status.mana}
		[if $attacker.status.mana < 0]
			[set $attacker.status.mana] 0
			[message] Not enough mana!
			[return]
		
		[set $local.attackScore] $= ( 20 - ( floor ( $battle.distance / 8 ) ) ) + ( 2 D 8 )
		[set $local.defenseScore] $= $defender.actualUsages.missile.compound.defense + ( 2 D 8 )
		
		[set $attacker.adhoc.battle.cooldown] 1
		
		[set $attacker.adhoc.battle.pressTarget] $defender
		[set $attacker.adhoc.battle.pressValue] 4
		
		[call battle/pressure] $attacker
		[call battle/pressure] $defender
		
		[if $defender.adhoc.battle.offensiveness > 0]
			[sub $local.defenseScore] 3
			[sub $local.defenseScore] $= ceil ( $defender.adhoc.battle.pressure / 2 )
		[elseif $defender.adhoc.battle.offensiveness < 0]
			[add $local.defenseScore] 2
			# Less sensible to the pressure when defending
			[sub $local.defenseScore] $= ceil ( $defender.adhoc.battle.pressure / 4 )
		[else]
			[sub $local.defenseScore] $= ceil ( $defender.adhoc.battle.pressure / 2 )
		
		#[message] $> ${local.attackScore} vs ${local.defenseScore}
		
		[message] $> ${attacker.label//uc1} cast a ^rfireball^ at ${defender.label}!
		
		[if $local.attackScore > $local.defenseScore]
			[gosub deal-damages]
				[args]
					hitFlavour:
						$$> ^rThe fireball hits ${defender.label} for ${damages} hp.^:
						$$> The ^rfireball^ explodes!
					criticalHitFlavour:
						$$> ^rThe fireball engulfs ${defender.label} for ${damages} hp.^:
						$$> The ^rfireball^ explodes!
					fatalHitFlavour:
						$$> ^rThe fireball burns ${defender.label} to death for ${damages} hp.^:
						$$> The ^rfireball^ explodes!
					damages: $= 24 + ( round ( $attacker.actual.stats.spellcasting / 4 ) )
			
			
			[gosub splash-damages]
				[args]
					attack: 25
					damages: $= 16 + ( round ( $attacker.actual.stats.spellcasting / 4 ) )
					radius: 1.8
					missFlavour: $$> ^y${target.label//uc1} evades the ^rfireball^y explosion.
					hitFlavour: $$> ^yThe ^rfireball^y explosion hits ${target.label} for ${damages} hp.
					criticalHitFlavour: $$> ^yThe ^rfireball^y explosion blows ${target.label} for ${damages} hp.
					fatalHitFlavour: $$> ^yThe ^rfireball^y explosion blasts ${target.label} for ${damages} hp.
			
		[else]
			[fortune]
				- $> The ^rfireball^ misses ${defender.label}.
				- $> ${defender.label//uc1} evades the ^rfireball^:.
				- $> ${defender.label//uc1} avoids the ^rfireball^:.
	
	
	
	[scene deadly-push]
		[set $local.attackScore] $= ( ( max $attacker.actual.stats.strength ( $attacker.actual.stats.fighting - 3 ) ) + $battle.deadlyPush.bonus ) + ( 2 D 6 )
		[set $local.defenseScore] $= $defender.actual.stats.strength + ( 2 D 6 )
		
		[sub $local.attackScore] $= $attacker.adhoc.battle.pressure / 4
		[sub $local.defenseScore] $= $defender.adhoc.battle.pressure / 4
		
		#[message] $> Attacker ${attacker.label} offensiveness: ${attacker.adhoc.battle.offensiveness}
		[if $attacker.adhoc.battle.offensiveness > 0]
			[add $local.attackScore] 2
			#[message] Offensive: bonus!
		[elseif $attacker.adhoc.battle.offensiveness < 0]
			[sub $local.attackScore] 3
			#[message] Defensive: malus!
		
		#[message] $> Defender ${defender.label} offensiveness: ${defender.adhoc.battle.offensiveness}
		[if $defender.adhoc.battle.offensiveness > 0]
			[sub $local.defenseScore] 3
			#[message] Offensive: malus!
		[elseif $defender.adhoc.battle.offensiveness < 0]
			[add $local.defenseScore] 2
			#[message] Defensive: bonus!
		
		[if $local.attackScore > $local.defenseScore]
			[set $defender.status.hp] 0
			[apply-to $local.flavour] $battle.deadlyPush.flavour
			[message] $local.flavour
		
		
	
	
