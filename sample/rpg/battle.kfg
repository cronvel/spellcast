
[[doctype adventurer]]

[chapter battle]
	
	[scene init]
		[set $battle] <Object>
		
		[set $battle.foes] <Array>
		[set $battle.turnIndex] 0
		[set $battle.turns] <Array>
		[set $battle.distance] $= ( $args.distance is-set? ) ? $args.distance 0
		
		[foreach $args.foes => $local.index : $local.foe]
			[if ! ( $local.foe is-entity? )]
				[create-entity $local.foe] $local.foe
			[set $battle.foes[$local.index]] $local.foe
			[append $battle.turns] $local.foe
			[set $local.foe.adhoc.battle]
				side: foes
				cooldown: 0
				offensiveness: $= ( $local.foe.stances.offensiveness is-set? ) ? $local.foe.stances.offensiveness 0
			
		[foreach $args.allies => $local.index : $local.ally]
			[if ! ( $local.ally is-entity? )]
				[create-entity $local.ally] $local.ally
			[set $battle.allies[$local.index]] $local.ally
			[append $battle.turns] $local.ally
			[set $local.ally.adhoc.battle]
				side: allies
				cooldown: 0
				offensiveness: $= ( $local.ally.stances.offensiveness is-set? ) ? $local.ally.stances.offensiveness 0
			
		[filter $battle.foes => $battle.aliveFoes] $= $this.status.hp > 0
		[filter $battle.allies => $battle.aliveAllies] $= $this.status.hp > 0
		
		#[debug info] $battle.allies
		#[debug info] $battle.foes
		#[debug info] $battle.aliveFoes
		#[debug info] $battle.turns
		
		
		[set $battle.deadlyPush] $args.deadlyPush
		
		[next initiative]
	
	
	
	[scene initiative]
		[foreach $battle.turns => $local.entity]
			[set $local.entity.adhoc.battle.initiativeScore] $= $local.entity.actual.stats.fighting + ( 2 D 8 )
		
			[if $local.entity.adhoc.battle.offensiveness > 0]
				[add $local.entity.adhoc.battle.initiativeScore] 2
			[elseif $local.entity.adhoc.battle.offensiveness < 0]
				[sub $local.entity.adhoc.battle.initiativeScore] 3
		
		[sort $battle.turns] $= - $this.adhoc.battle.initiativeScore
		
		#[debug info] $battle.turns
		[message] $> ${battle.turns[0].label//uc1} takes the initiative.
		[goto new-turn]
		
	
	
	[scene new-turn]
		[set $battle.entityTurn] $= $battle.turns[$battle.turnIndex]
		
		[if $battle.entityTurn.status.hp <= 0]
			[goto end-turn]
		
		[if $battle.entityTurn.adhoc.battle.cooldown > 0]
			[dec $battle.entityTurn.adhoc.battle.cooldown]
			[goto end-turn]
		
		[gosub battle-lines]
		
		[if $battle.entityTurn.npc]
			[goto npc-turn]
		[else]
			[goto pc-turn]
	
	
	
	[scene end-turn]
		[set $battle.turnIndex] $= ( $battle.turnIndex + 1 ) % $battle.turns.length
		
		[filter $battle.foes => $battle.aliveFoes] $= $this.status.hp > 0
		[filter $battle.allies => $battle.aliveAllies] $= $this.status.hp > 0
		
		[if ! $battle.aliveAllies.length]
			[goto lost]
		[elseif ! $battle.aliveFoes.length]
			[goto win]
		[else]
			[goto new-turn]
	
	
	
	[scene battle-lines]
		
		[filter $battle.aliveFoes => $front] $= $this.adhoc.battle.offensiveness > 0
		[filter $battle.aliveFoes => $middle] $= $this.adhoc.battle.offensiveness = 0
		[filter $battle.aliveFoes => $back] $= $this.adhoc.battle.offensiveness < 0
		
		[set $offset] $= ceil ( ( 1 - $front.length ) / 2 )
		[foreach $front => $index : $entity]
			[set $entity.adhoc.battle.position]
				x: $battle.distance
				y: $= $index + $offset
		
		[set $offset] $= ceil ( ( 1 - $middle.length ) / 2 )
		[foreach $middle => $index : $entity]
			[set $entity.adhoc.battle.position]
				x: $= $battle.distance + 1
				y: $= $index + $offset
		
		[set $offset] $= ceil ( ( 1 - $back.length ) / 2 )
		[foreach $back => $index : $entity]
			[set $entity.adhoc.battle.position]
				x: $= $battle.distance + 2
				y: $= $index + $offset
		
		[sort $battle.aliveFoes] $= $this.adhoc.battle.position.y + ( $this.adhoc.battle.position.x / 1000 )
		
		#[map $battle.aliveFoes => $tmp] $this.adhoc.battle
		#[debug info] $tmp
		
		# Same for allies
		
		[filter $battle.aliveAllies => $front] $= $this.adhoc.battle.offensiveness > 0
		[filter $battle.aliveAllies => $middle] $= $this.adhoc.battle.offensiveness = 0
		[filter $battle.aliveAllies => $back] $= $this.adhoc.battle.offensiveness < 0
		
		[set $offset] $= ceil ( ( 1 - $front.length ) / 2 )
		[foreach $front => $index : $entity]
			[set $entity.adhoc.battle.position]
				x: $= - $battle.distance
				y: $= $index + $offset
		
		[set $offset] $= ceil ( ( 1 - $middle.length ) / 2 )
		[foreach $middle => $index : $entity]
			[set $entity.adhoc.battle.position]
				x: $= ( - $battle.distance ) - 1
				y: $= $index + $offset
		
		[set $offset] $= ceil ( ( 1 - $back.length ) / 2 )
		[foreach $back => $index : $entity]
			[set $entity.adhoc.battle.position]
				x: $= ( - $battle.distance ) - 2
				y: $= $index + $offset
			
		[sort $battle.aliveAllies] $= $this.adhoc.battle.position.y + ( $this.adhoc.battle.position.x / 1000 )
		
	
	[scene npc-turn]
		
		[gosub npc-targeting]
		
		[set $attacker] $battle.entityTurn
		
		[if $attacker.params.battleCry && ( ( random ) <= $attacker.params.battleCry )]
			[if $attacker.params.battleCryFlavour]
				[apply-to $local.flavour] $= random-element $attacker.params.battleCryFlavour
				[message] $local.flavour
			[else]
				[message] $> ${attacker.label//uc1} shouts!
		
		
		[if $attacker.params.charge && ( ( random ) <= $attacker.params.charge )]
			[gosub charge]
				[args]
					attacker: $attacker
					defender: $battle.target
			[goto end-turn]
		
		[gosub melee]
			[args]
				attacker: $attacker
				defender: $battle.target
		
		[goto end-turn]
		
	
	
	[scene pc-turn]
		[next pc-melee]
			[label] Attack
			[on-trigger]
				[set $battle.entityTurn.adhoc.battle.offensiveness] 0
		
		[next pc-melee]
			[label] Attack boldly
			[on-trigger]
				[set $battle.entityTurn.adhoc.battle.offensiveness] 1
		
		[next pc-melee]
			[label] Attack caustiously
			[on-trigger]
				[set $battle.entityTurn.adhoc.battle.offensiveness] -1
		
		[next pc-charge]
			[label] Charge!
	
		[next pc-fireball]
			[label] Fireball
	
	
	
	[scene npc-targeting]
		
		[if $battle.entityTurn.adhoc.battle.side = "allies"]
			[set $local.enemies] $battle.aliveFoes
		[else]
			[set $local.enemies] $battle.aliveAllies
		
		[set $local.index] $= random ( $local.enemies.length - 1 )
		[set $battle.target] $local.enemies[$local.index]
	
	
	
	[scene pc-targeting]
		[set $local.count] 0
		
		[if $battle.entityTurn.adhoc.battle.side = "allies"]
			[set $local.enemies] $battle.aliveFoes
		[else]
			[set $local.enemies] $battle.aliveAllies
		
		[if $local.enemies.length <= 1]
			[set $battle.target] $local.enemies[0]
			[return]
		
		[message] Target?
		
		[foreach $local.enemies => $local.index : $local.entity]
			[if $local.entity.adhoc.battle.offensiveness > 0]
				[set $local.position] "←"
			[elseif $local.entity.adhoc.battle.offensiveness < 0]
				[set $local.position] "→    "
			[else]
				[set $local.position] "   "
			
			[next]
				[args]
					index: $local.index
				[label] $> ${local.position} ${local.entity.label//uc1}
				[on-trigger]
					[set $battle.target] $local.enemies[$args.index]
	
	
	
	[scene pc-melee]
		[gosub pc-targeting]
		[gosub melee]
			[args]
				attacker: $battle.entityTurn
				defender: $battle.target
		[goto end-turn]
	
	
	
	[scene pc-charge]
		[gosub pc-targeting]
		[gosub charge]
			[args]
				attacker: $battle.entityTurn
				defender: $battle.target
		[goto end-turn]
	
	
	
	[scene pc-fireball]
		[gosub pc-targeting]
		[gosub fireball]
			[args]
				attacker: $battle.entityTurn
				defender: $battle.target
		[goto end-turn]
	
	
	
	[scene win]
		[message] $> ${battle.allies[0].label//uc1} win the battle.
		[set $local.xpReward] 0
		
		[foreach $battle.foes => $local.entity]
			[add $local.xpReward] $local.entity.params.xpReward
		
		[set $local.xpReward] $= ceil ( $local.xpReward / $battle.allies.length )
		
		[foreach $battle.allies => $local.index : $local.entity]
			[add $local.entity.status.xp] $local.xpReward
		
		[message] $> You gain ${local.xpReward} xp (=${battle.allies[0].status.xp}).
	
	
	
	[scene lost]
		[message] $> ${battle.allies[0].label//uc1} died on the battlefield.
		[lost]

	
	
	#melee damage
	[scene deal-damages]
		[if $args.defender]
			[set $defender] $args.defender
		
		# Damage level
		[if $args.damages is-real?]
			[set $local.attackScore] $= $args.damages + ( 2 D 6 )
		[else]
			[set $local.attackScore] $= $attacker.actualUsages.melee.compound.damages + ( 2 D 6 )
			
			# Attacker offensiveness is used only when not using fixed damage base
			[if $attacker.adhoc.battle.offensiveness > 0]
				[add $local.attackScore] 2
			[elseif $attacker.adhoc.battle.offensiveness < 0]
				[sub $local.attackScore] 3
			
		
		[set $local.defenseScore] $= $defender.actual.stats.resilience + ( 2 D 6 )
		
		# Always used?
		[if $defender.adhoc.battle.offensiveness > 0]
			[sub $local.defenseScore] 3
		[elseif $defender.adhoc.battle.offensiveness < 0]
			[add $local.defenseScore] 2
		
		#[message] $> ${local.attackScore} vs ${local.defenseScore}
		
		[set $damages] $= ( ( $local.attackScore - $local.defenseScore ) + ( random ) ) - 0.5
		
		
		[if $args.bonus is-real?]
			[add $damages] $args.bonus
		
		#[message] $> damages: ${damages}
		
		# This is the magic formula that transform damage levels into real hit point loss, with the correct feeling
		# damage-level = +20 is needed for an instant death
		[set $damages] $= round ( 10 * ( 2 ^ ( $damages / 6 ) ) )
		
		#[message] $> damages: ${damages}
		
		[sub $defender.status.hp] $damages
		
		[if $damages >= 100]
			[if $args.fatalHitFlavour is-set?]
				[apply-to $local.flavour] $args.fatalHitFlavour
			[elseif $args.criticalHitFlavour is-set?]
				[apply-to $local.flavour] $args.criticalHitFlavour
			[elseif $args.hitFlavour is-set?]
				[apply-to $local.flavour] $args.hitFlavour
			[elseif $attacker.actualUsages.melee.params.fatalHitFlavour is-set?]
				[apply-to $local.flavour] $attacker.actualUsages.melee.params.fatalHitFlavour
			[elseif $attacker.actualUsages.melee.params.criticalHitFlavour is-set?]
				[apply-to $local.flavour] $attacker.actualUsages.melee.params.criticalHitFlavour
			[elseif $attacker.actualUsages.melee.params.hitFlavour is-set?]
				[apply-to $local.flavour] $attacker.actualUsages.melee.params.hitFlavour
			[else]
				[set $local.flavour] $> ^r${attacker.label//uc1} deadly hits ${defender.label} for ${damages} hp.
		[elseif $damages >= 25]
			[if $args.criticalHitFlavour is-set?]
				[apply-to $local.flavour] $args.criticalHitFlavour
			[elseif $args.hitFlavour is-set?]
				[apply-to $local.flavour] $args.hitFlavour
			[elseif $attacker.actualUsages.melee.params.criticalHitFlavour is-set?]
				[apply-to $local.flavour] $attacker.actualUsages.melee.params.criticalHitFlavour
			[elseif $attacker.actualUsages.melee.params.hitFlavour is-set?]
				[apply-to $local.flavour] $attacker.actualUsages.melee.params.hitFlavour
			[else]
				[set $local.flavour] $> ^r${attacker.label//uc1} critically hits ${defender.label} for ${damages} hp.
		[else]
			[if $args.hitFlavour is-set?]
				[apply-to $local.flavour] $args.hitFlavour
			[elseif $attacker.actualUsages.melee.params.hitFlavour is-set?]
				[apply-to $local.flavour] $attacker.actualUsages.melee.params.hitFlavour
			[else]
				[set $local.flavour] $> ^r${attacker.label//uc1} hits ${defender.label} for ${damages} hp.
		
		[message] $local.flavour
		
		[if $defender.status.hp <= 0]
			[message] $> ^R^+${defender.label//uc1} is dead.
	
	
	
	[scene splash-damages]
		[set $aliveEntities] <Array>
		[concat $aliveEntities] $battle.aliveFoes
		[concat $aliveEntities] $battle.aliveAllies
		[set $pos] $defender.adhoc.battle.position
		
		[foreach $aliveEntities => $target]
			
			[if ( $target = $defender ) || ( $target = $attacker )]
				[continue]
			
			[set $targetPos] $target.adhoc.battle.position
			
			[if ( hypot ( $targetPos.x - $pos.x ) ( $targetPos.y - $pos.y ) ) <= $args.radius]
				
				[set $local.attackScore] $= $args.attack + ( 2 D 8 )
# Or use $target.actualUsages.missile.compound.defense?
				[set $local.defenseScore] $= $target.actualUsages.melee.compound.defense + ( 2 D 8 )
				
				[if $target.adhoc.battle.offensiveness > 0]
					[sub $local.defenseScore] 3
				[elseif $target.adhoc.battle.offensiveness < 0]
					[add $local.defenseScore] 2
				
				[if $local.attackScore > $local.defenseScore]
					[gosub deal-damages]
						[args]
							defender: $target
							hitFlavour: $args.hitFlavour
							criticalHitFlavour: $args.criticalHitFlavour
							fatalHitFlavour: $args.fatalHitFlavour
							damages: $args.damages
				
				[else]
					[if $args.missFlavour]
						[apply-to $flavour] $args.missFlavour
						[message] $flavour
			
	
	
	[scene melee]
		[set $attacker] $args.attacker
		[set $defender] $args.defender
		
		[set $local.attackScore] $= $attacker.actualUsages.melee.compound.attack + ( 2 D 8 )
		[set $local.defenseScore] $= $defender.actualUsages.melee.compound.defense + ( 2 D 8 )
		
		[if $attacker.adhoc.battle.offensiveness > 0]
			[add $local.attackScore] 2
		[elseif $attacker.adhoc.battle.offensiveness < 0]
			[sub $local.attackScore] 3
		
		[if $defender.adhoc.battle.offensiveness > 0]
			[sub $local.defenseScore] 3
		[elseif $defender.adhoc.battle.offensiveness < 0]
			[add $local.defenseScore] 2
		
		#[message] $> ${local.attackScore} vs ${local.defenseScore}
		
		[if $local.attackScore > $local.defenseScore]
			[gosub deal-damages]
			
		[else]
			[fortune]
				- $> ${attacker.label//uc1} misses ${defender.label}.
				- $> ${defender.label//uc1} blocks ${attacker.label}.
				- $> ${defender.label//uc1} avoids ${attacker.label}.
	
	
	
	[scene charge]
		[set $attacker] $args.attacker
		[set $defender] $args.defender
		
		#[set $attacker.adhoc.battle.cooldown] 1
		
		[set $attacker.adhoc.battle.offensiveness] 1
		
		[set $local.attackScore] $= $attacker.actualUsages.melee.compound.attack + ( 2 D 8 )
		[set $local.defenseScore] $= $defender.actualUsages.melee.compound.defense + ( 2 D 8 )
		
		#[message] $> Attacker ${attacker.label} offensiveness: ${attacker.adhoc.battle.offensiveness}
		[if $attacker.adhoc.battle.offensiveness > 0]
			[add $local.attackScore] 2
			#[message] Offensive: bonus!
		[elseif $attacker.adhoc.battle.offensiveness < 0]
			[sub $local.attackScore] 3
			#[message] Defensive: malus!
		
		#[message] $> Defender ${defender.label} offensiveness: ${defender.adhoc.battle.offensiveness}
		[if $defender.adhoc.battle.offensiveness > 0]
			[sub $local.defenseScore] 3
			#[message] Offensive: malus!
		[elseif $defender.adhoc.battle.offensiveness < 0]
			[add $local.defenseScore] 2
			#[message] Defensive: bonus!
		
		#[message] $> ${local.attackScore} vs ${local.defenseScore}
		
		[message] $> ${attacker.label//uc1} charges ${defender.label}!
		
		[if $local.attackScore > $local.defenseScore]
			[gosub deal-damages]
			
			[if $battle.deadlyPush]
				[gosub deadly-push]
		[elseif ( $local.attackScore = $local.defenseScore ) && $battle.deadlyPush]
			[message] $> ${defender.label//uc1} blocks ${attacker.label}.
			[gosub deadly-push]
		[else]
			[fortune]
				- $> ${attacker.label//uc1} misses ${defender.label}.
				- $> ${defender.label//uc1} blocks ${attacker.label}.
				- $> ${defender.label//uc1} avoids ${attacker.label}.
	
	
	
	[scene fireball]
		[set $attacker] $args.attacker
		[set $defender] $args.defender
		
		[sub $attacker.status.mana] 6
		[message] $> mana: ${attacker.status.mana}
		[if $attacker.status.mana < 0]
			[set $attacker.status.mana] 0
			[message] Not enough mana!
			[return]
		
		[set $attacker.adhoc.battle.cooldown] 1
		[set $local.attackScore] $= ( 20 ) + ( 2 D 8 )
		[set $local.defenseScore] $= $defender.actualUsages.missile.compound.defense + ( 2 D 8 )
		
		[if $defender.adhoc.battle.offensiveness > 0]
			[sub $local.defenseScore] 3
		[elseif $defender.adhoc.battle.offensiveness < 0]
			[add $local.defenseScore] 2
		
		#[message] $> ${local.attackScore} vs ${local.defenseScore}
		
		[message] $> ${attacker.label//uc1} cast a ^rfireball^ at ${defender.label}!
		
		[if $local.attackScore > $local.defenseScore]
			[gosub deal-damages]
				[args]
					hitFlavour:
						$$> ^rThe fireball hits ${defender.label} for ${damages} hp.^:
						$$> The ^rfireball^ explodes!
					criticalHitFlavour:
						$$> ^rThe fireball engulfs ${defender.label} for ${damages} hp.^:
						$$> The ^rfireball^ explodes!
					fatalHitFlavour:
						$$> ^rThe fireball burns ${defender.label} to death for ${damages} hp.^:
						$$> The ^rfireball^ explodes!
					damages: $= 24 + ( round ( $attacker.actual.stats.spellcasting / 4 ) )
			
			
			[gosub splash-damages]
				[args]
					attack: 25
					damages: $= 16 + ( round ( $attacker.actual.stats.spellcasting / 4 ) )
					radius: 1.8
					missFlavour: $$> ^y${target.label//uc1} evades the ^rfireball^y explosion.
					hitFlavour: $$> ^yThe ^rfireball^y explosion hits ${target.label} for ${damages} hp.
					criticalHitFlavour: $$> ^yThe ^rfireball^y explosion blows ${target.label} for ${damages} hp.
					fatalHitFlavour: $$> ^yThe ^rfireball^y explosion blasts ${target.label} for ${damages} hp.
			
		[else]
			[fortune]
				- $> The ^rfireball^ misses ${defender.label}.
				- $> ${defender.label//uc1} evades the ^rfireball^:.
				- $> ${defender.label//uc1} avoids the ^rfireball^:.
	
	
	
	[scene deadly-push]
		[set $local.attackScore] $= ( ( max $attacker.actual.stats.strength ( $attacker.actual.stats.fighting - 3 ) ) + $battle.deadlyPush.bonus ) + ( 2 D 6 )
		[set $local.defenseScore] $= $defender.actual.stats.strength + ( 2 D 6 )
		
		#[message] $> Attacker ${attacker.label} offensiveness: ${attacker.adhoc.battle.offensiveness}
		[if $attacker.adhoc.battle.offensiveness > 0]
			[add $local.attackScore] 2
			#[message] Offensive: bonus!
		[elseif $attacker.adhoc.battle.offensiveness < 0]
			[sub $local.attackScore] 3
			#[message] Defensive: malus!
		
		#[message] $> Defender ${defender.label} offensiveness: ${defender.adhoc.battle.offensiveness}
		[if $defender.adhoc.battle.offensiveness > 0]
			[sub $local.defenseScore] 3
			#[message] Offensive: malus!
		[elseif $defender.adhoc.battle.offensiveness < 0]
			[add $local.defenseScore] 2
			#[message] Defensive: bonus!
		
		[if $local.attackScore > $local.defenseScore]
			[set $defender.status.hp] 0
			[apply-to $local.flavour] $battle.deadlyPush.flavour
			[message] $local.flavour
		
		
	
	
