
[[doctype adventurer]]

[chapter battle]
	
	[scene init]
		[set $battle] <Object>
		
		[set $battle.foes] <Array>
		[set $battle.turnIndex] 0
		[set $battle.turns] <Array>
		
		[foreach $args.foes => $local.index : $local.foe]
			[if ! ( $local.foe is-entity? )]
				[create-entity $local.foe] $local.foe
			[set $battle.foes[$local.index]] $local.foe
			[append $battle.turns] $local.foe
			[set $local.foe.adhoc.battle]
				side: foes
				cooldown: 0
				offensiveness: $= ( $local.foe.stances.offensiveness is-set? ) ? $local.foe.stances.offensiveness 0
			
		[foreach $args.allies => $local.index : $local.ally]
			[if ! ( $local.ally is-entity? )]
				[create-entity $local.ally] $local.ally
			[set $battle.allies[$local.index]] $local.ally
			[append $battle.turns] $local.ally
			[set $local.ally.adhoc.battle]
				side: allies
				cooldown: 0
				offensiveness: $= ( $local.ally.stances.offensiveness is-set? ) ? $local.ally.stances.offensiveness 0
			
		#[debug info] $battle.allies
		#[debug info] $battle.foes
		#[debug info] $battle.turns
		
		[set $battle.deadlyPush] $args.deadlyPush
		
		[next initiative]
	
	
	
	[scene initiative]
		[foreach $battle.turns => $local.entity]
			[set $local.entity.adhoc.battle.initiativeScore] $= $local.entity.actual.stats.fighting + ( 2 D 8 )
		
			[if $local.entity.adhoc.battle.offensiveness > 0]
				[set $local.entity.adhoc.battle.initiativeScore] $= $local.entity.adhoc.battle.initiativeScore + 2
			[elseif $local.entity.adhoc.battle.offensiveness < 0]
				[set $local.entity.adhoc.battle.initiativeScore] $= $local.entity.adhoc.battle.initiativeScore - 3
		
		[sort $battle.turns]
			key: $adhoc.battle.initiativeScore
			order: desc
		
		#[debug info] $battle.turns
		[message] $> ${battle.turns[0].label//uc1} takes the initiative.
		[goto new-turn]
		
	
	
	[scene new-turn]
		[set $battle.entityTurn] $= $battle.turns[$battle.turnIndex]
		
		[if $battle.entityTurn.status.hp <= 0]
			[goto end-turn]
		
		[if $battle.entityTurn.adhoc.battle.cooldown > 0]
			[set $battle.entityTurn.adhoc.battle.cooldown] $= $battle.entityTurn.adhoc.battle.cooldown - 1
			[goto end-turn]
		
		[if $battle.entityTurn.npc]
			[goto npc-turn]
		[else]
			[goto pc-turn]
	
	
	
	[scene end-turn]
		[set $battle.turnIndex] $= ( $battle.turnIndex + 1 ) % $battle.turns.length
		
		[set $local.alliesAlive] 0
		[set $local.foesAlive] 0
		
		[foreach $battle.allies => $local.entity]
			[if $local.entity.status.hp > 0]
				[set $local.alliesAlive] $= $local.alliesAlive + 1
		
		[foreach $battle.foes => $local.entity]
			[if $local.entity.status.hp > 0]
				[set $local.foesAlive] $= $local.foesAlive + 1
		
		#[message] $> Alive: ${local.alliesAlive} ${local.foesAlive}
		
		[if ! $local.alliesAlive]
			[goto lost]
		[elseif ! $local.foesAlive]
			[goto win]
		[else]
			[goto new-turn]
	
	
	
	[scene npc-turn]
		
		[gosub npc-targeting]
		
		[set $attacker] $battle.entityTurn
		
		[if $attacker.params.battleCry && ( ( random ) <= $attacker.params.battleCry )]
			[if $attacker.params.battleCryFlavour]
				[apply-to $local.flavour] $= random-element $attacker.params.battleCryFlavour
				[message] $local.flavour
			[else]
				[message] $> ${attacker.label//uc1} shouts!
		
		
		[if $attacker.params.charge && ( ( random ) <= $attacker.params.charge )]
			[gosub charge]
				[args]
					attacker: $attacker
					defender: $battle.target
			[goto end-turn]
		
		[gosub melee]
			[args]
				attacker: $attacker
				defender: $battle.target
		
		[goto end-turn]
		
	
	
	[scene pc-turn]
		[next pc-melee]
			[label] Attack
			[on-trigger]
				[set $battle.entityTurn.adhoc.battle.offensiveness] 0
		
		[next pc-melee]
			[label] Attack boldly
			[on-trigger]
				[set $battle.entityTurn.adhoc.battle.offensiveness] 1
		
		[next pc-melee]
			[label] Attack caustiously
			[on-trigger]
				[set $battle.entityTurn.adhoc.battle.offensiveness] -1
		
		[next pc-charge]
			[label] Charge!
	
		[next pc-fireball]
			[label] Fireball
	
	
	
	[scene npc-targeting]
		
		[if $battle.entityTurn.adhoc.battle.side = "allies"]
			[set $local.enemies] $battle.foes
		[else]
			[set $local.enemies] $battle.allies
		
		[set $local.enemiesAlive] <Array>
		
		[foreach $local.enemies => $local.entity]
			[if $local.entity.status.hp > 0]
				[append $local.enemiesAlive] $local.entity
				[set $battle.target] $local.entity
		
		[if $local.enemiesAlive.length <= 1]
			[return]
		
		[set $local.index] $= random ( $local.enemiesAlive.length - 1 )
		[set $battle.target] $local.enemiesAlive[$local.index]
	
	
	
	[scene pc-targeting]
		[set $local.count] 0
		
		[if $battle.entityTurn.adhoc.battle.side = "allies"]
			[set $local.enemies] $battle.foes
		[else]
			[set $local.enemies] $battle.allies
		
		[foreach $local.enemies => $local.entity]
			[if $local.entity.status.hp > 0]
				[set $local.count] $= $local.count + 1
				[set $battle.target] $local.entity
		
		[if $local.count <= 1]
			[return]
		
		[message] Target?
		
		[foreach $local.enemies => $local.index : $local.entity]
			[if $local.entity.status.hp > 0]
				
				[if $local.entity.adhoc.battle.offensiveness > 0]
					[set $local.position] $>  (front/offensive)
				[elseif $local.entity.adhoc.battle.offensiveness < 0]
					[set $local.position] $>  (rear/defensive)
				[else]
					[set $local.position] ""
				
				[next]
					[args]
						index: $local.index
					[label] $> ${local.entity.label//uc1}${local.position}
					[on-trigger]
						[set $battle.target] $local.enemies[$args.index]
	
	
	
	[scene pc-melee]
		[gosub pc-targeting]
		[gosub melee]
			[args]
				attacker: $battle.entityTurn
				defender: $battle.target
		[goto end-turn]
	
	
	
	[scene pc-charge]
		[gosub pc-targeting]
		[gosub charge]
			[args]
				attacker: $battle.entityTurn
				defender: $battle.target
		[goto end-turn]
	
	
	
	[scene pc-fireball]
		[gosub pc-targeting]
		[gosub fireball]
			[args]
				attacker: $battle.entityTurn
				defender: $battle.target
		[goto end-turn]
	
	
	
	[scene win]
		[message] $> ${battle.allies[0].label//uc1} win the battle.
		[set $local.xpReward] 0
		
		[foreach $battle.foes => $local.entity]
			[set $local.xpReward] $= $local.xpReward + $local.entity.params.xpReward
		
		[set $local.xpReward] $= ceil ( $local.xpReward / $battle.allies.length )
		
		[foreach $battle.allies => $local.index : $local.entity]
			[set $local.entity.status.xp] $= $local.entity.status.xp + $local.xpReward
		
		[message] $> You gain ${local.xpReward} xp (=${battle.allies[0].status.xp}).
	
	
	
	[scene lost]
		[message] $> ${battle.allies[0].label//uc1} died on the battlefield.
		[lost]

	
	
	#melee damage
	[scene deal-damages]
		[if $args.defender]
			[set $defender] $args.defender
		
		# Damage level
		[if $args.damages is-real?]
			[set $local.attackScore] $= $args.damages + ( 2 D 6 )
		[else]
			[set $local.attackScore] $= $attacker.actualUsages.melee.compound.damages + ( 2 D 6 )
			
			# Attacker offensiveness is used only when not using fixed damage base
			[if $attacker.adhoc.battle.offensiveness > 0]
				[set $local.attackScore] $= $local.attackScore + 2
			[elseif $attacker.adhoc.battle.offensiveness < 0]
				[set $local.attackScore] $= $local.attackScore - 3
			
		
		[set $local.defenseScore] $= $defender.actual.stats.resilience + ( 2 D 6 )
		
		# Always used?
		[if $defender.adhoc.battle.offensiveness > 0]
			[set $local.defenseScore] $= $local.defenseScore - 3
		[elseif $defender.adhoc.battle.offensiveness < 0]
			[set $local.defenseScore] $= $local.defenseScore + 2
		
		#[message] $> ${local.attackScore} vs ${local.defenseScore}
		
		[set $damages] $= ( ( $local.attackScore - $local.defenseScore ) + ( random ) ) - 0.5
		
		
		[if $args.bonus is-real?]
			[set $damages] $= $damages + $args.bonus
		
		#[message] $> damages: ${damages}
		[set $damages] $= round ( 10 * ( 2 ^ ( $damages / 5 ) ) )
		#[message] $> damages: ${damages}
		
		[set $defender.status.hp] $= $defender.status.hp - $damages
		
		[if $damages >= 100]
			[if $args.fatalHitFlavour is-set?]
				[apply-to $local.flavour] $args.fatalHitFlavour
			[elseif $args.criticalHitFlavour is-set?]
				[apply-to $local.flavour] $args.criticalHitFlavour
			[elseif $args.hitFlavour is-set?]
				[apply-to $local.flavour] $args.hitFlavour
			[elseif $attacker.actualUsages.melee.params.fatalHitFlavour is-set?]
				[apply-to $local.flavour] $attacker.actualUsages.melee.params.fatalHitFlavour
			[elseif $attacker.actualUsages.melee.params.criticalHitFlavour is-set?]
				[apply-to $local.flavour] $attacker.actualUsages.melee.params.criticalHitFlavour
			[elseif $attacker.actualUsages.melee.params.hitFlavour is-set?]
				[apply-to $local.flavour] $attacker.actualUsages.melee.params.hitFlavour
			[else]
				[set $local.flavour] $> ^r${attacker.label//uc1} deadly hits ${defender.label} for ${damages} hp.
		[elseif $damages >= 25]
			[if $args.criticalHitFlavour is-set?]
				[apply-to $local.flavour] $args.criticalHitFlavour
			[elseif $args.hitFlavour is-set?]
				[apply-to $local.flavour] $args.hitFlavour
			[elseif $attacker.actualUsages.melee.params.criticalHitFlavour is-set?]
				[apply-to $local.flavour] $attacker.actualUsages.melee.params.criticalHitFlavour
			[elseif $attacker.actualUsages.melee.params.hitFlavour is-set?]
				[apply-to $local.flavour] $attacker.actualUsages.melee.params.hitFlavour
			[else]
				[set $local.flavour] $> ^r${attacker.label//uc1} critically hits ${defender.label} for ${damages} hp.
		[else]
			[if $args.hitFlavour is-set?]
				[apply-to $local.flavour] $args.hitFlavour
			[elseif $attacker.actualUsages.melee.params.hitFlavour is-set?]
				[apply-to $local.flavour] $attacker.actualUsages.melee.params.hitFlavour
			[else]
				[set $local.flavour] $> ^r${attacker.label//uc1} hits ${defender.label} for ${damages} hp.
		
		[message] $local.flavour
		
		[if $defender.status.hp <= 0]
			[message] $> ^R^+${defender.label//uc1} is dead.
	
	
	
	[scene splash-damages]
		# /!\ Should randomize the array first...
		[foreach $battle.turns => $target]
			[if $args.targetCount <= 0]
				[break]
			
			[if ( $target.status.hp <= 0 )]
				[continue]
			[if ( $target = $defender ) || ( $target = $attacker )]
				[continue]
			[if ( $target.adhoc.battle.side = $attacker.adhoc.battle.side )]
				[continue]
			
			[if ( random ) <= $args.targetChance )]
				[set $args.targetCount] $= $args.targetCount - 1
				
				[gosub deal-damages]
					[args]
						defender: $target
						hitFlavour: $args.hitFlavour
						criticalHitFlavour: $args.criticalHitFlavour
						fatalHitFlavour: $args.fatalHitFlavour
						damages: $args.damages
			
	
	
	[scene melee]
		[set $attacker] $args.attacker
		[set $defender] $args.defender
		
		[set $local.attackScore] $= $attacker.actualUsages.melee.compound.attack + ( 2 D 8 )
		[set $local.defenseScore] $= $defender.actualUsages.melee.compound.defense + ( 2 D 8 )
		
		#[message] $> Before: ${local.attackScore} vs ${local.defenseScore}
		#[message] $> Attacker ${attacker.label} offensiveness: ${attacker.adhoc.battle.offensiveness}
		[if $attacker.adhoc.battle.offensiveness > 0]
			[set $local.attackScore] $= $local.attackScore + 2
			#[message] Offensive: bonus!
		[elseif $attacker.adhoc.battle.offensiveness < 0]
			[set $local.attackScore] $= $local.attackScore - 3
			#[message] Defensive: malus!
		
		#[message] $> Defender ${defender.label} offensiveness: ${defender.adhoc.battle.offensiveness}
		[if $defender.adhoc.battle.offensiveness > 0]
			[set $local.defenseScore] $= $local.defenseScore - 3
			#[message] Offensive: malus!
		[elseif $defender.adhoc.battle.offensiveness < 0]
			[set $local.defenseScore] $= $local.defenseScore + 2
			#[message] Defensive: bonus!
		
		#[message] $> (${attacker.actualUsages.melee.compound.attack} vs ${defender.actualUsages.melee.compound.defense})
		#[message] $> ${local.attackScore} vs ${local.defenseScore}
		
		[if $local.attackScore > $local.defenseScore]
			[gosub deal-damages]
			
		[else]
			[fortune]
				- $> ${attacker.label//uc1} misses ${defender.label}.
				- $> ${defender.label//uc1} blocks ${attacker.label}.
				- $> ${defender.label//uc1} avoids ${attacker.label}.
	
	
	
	[scene charge]
		[set $attacker] $args.attacker
		[set $defender] $args.defender
		
		#[set $attacker.adhoc.battle.cooldown] 1
		
		[set $attacker.adhoc.battle.offensiveness] 1
		
		[set $local.attackScore] $= $attacker.actualUsages.melee.compound.attack + ( 2 D 8 )
		[set $local.defenseScore] $= $defender.actualUsages.melee.compound.defense + ( 2 D 8 )
		
		#[message] $> Attacker ${attacker.label} offensiveness: ${attacker.adhoc.battle.offensiveness}
		[if $attacker.adhoc.battle.offensiveness > 0]
			[set $local.attackScore] $= $local.attackScore + 2
			#[message] Offensive: bonus!
		[elseif $attacker.adhoc.battle.offensiveness < 0]
			[set $local.attackScore] $= $local.attackScore - 3
			#[message] Defensive: malus!
		
		#[message] $> Defender ${defender.label} offensiveness: ${defender.adhoc.battle.offensiveness}
		[if $defender.adhoc.battle.offensiveness > 0]
			[set $local.defenseScore] $= $local.defenseScore - 3
			#[message] Offensive: malus!
		[elseif $defender.adhoc.battle.offensiveness < 0]
			[set $local.defenseScore] $= $local.defenseScore + 2
			#[message] Defensive: bonus!
		
		#[message] $> ${local.attackScore} vs ${local.defenseScore}
		
		[message] $> ${attacker.label//uc1} charges ${defender.label}!
		
		[if $local.attackScore > $local.defenseScore]
			[gosub deal-damages]
			
			[if $battle.deadlyPush]
				[gosub deadly-push]
		[elseif ( $local.attackScore = $local.defenseScore ) && $battle.deadlyPush]
			[message] $> ${defender.label//uc1} blocks ${attacker.label}.
			[gosub deadly-push]
		[else]
			[fortune]
				- $> ${attacker.label//uc1} misses ${defender.label}.
				- $> ${defender.label//uc1} blocks ${attacker.label}.
				- $> ${defender.label//uc1} avoids ${attacker.label}.
	
	
	
	[scene fireball]
		[set $attacker] $args.attacker
		[set $defender] $args.defender
		
		[set $attacker.status.mana] $= $attacker.status.mana - 6
		[message] $> mana: ${attacker.status.mana}
		[if $attacker.status.mana < 0]
			[set $attacker.status.mana] 0
			[message] Not enough mana!
			[return]
		
		[set $attacker.adhoc.battle.cooldown] 1
		[set $local.attackScore] $= ( 20 ) + ( 2 D 8 )
		[set $local.defenseScore] $= $defender.actualUsages.missile.compound.defense + ( 2 D 8 )
		
		#[message] $> Defender ${defender.label} offensiveness: ${defender.adhoc.battle.offensiveness}
		[if $defender.adhoc.battle.offensiveness > 0]
			[set $local.defenseScore] $= $local.defenseScore - 3
			#[message] Offensive: malus!
		[elseif $defender.adhoc.battle.offensiveness < 0]
			[set $local.defenseScore] $= $local.defenseScore + 2
			#[message] Defensive: bonus!
		
		#[message] $> Scores: ${local.attackScore} vs ${local.defenseScore}
		
		[message] $> ${attacker.label//uc1} cast a ^rfireball^ at ${defender.label}!
		
		[if $local.attackScore > $local.defenseScore]
			[gosub deal-damages]
				[args]
					hitFlavour:
						$$> ^rThe fireball hits ${defender.label} for ${damages} hp.^:
						$$> The ^rfireball^ explodes!
					criticalHitFlavour:
						$$> ^rThe fireball engulf ${defender.label} for ${damages} hp.^:
						$$> The ^rfireball^ explodes!
					fatalHitFlavour:
						$$> ^rThe fireball burns ${defender.label} to death for ${damages} hp.^:
						$$> The ^rfireball^ explodes!
					damages: $= 20 + ( round ( $attacker.actual.stats.spellcasting / 4 ) )
			
			
			[gosub splash-damages]
				[args]
					damages: $= 12 + ( round ( $attacker.actual.stats.spellcasting / 4 ) )
					hitFlavour: $$> ^yThe ^rfireball^y explosion hits ${target.label} for ${damages} hp.
					criticalHitFlavour: $$> ^yThe ^rfireball^y explosion blow ${target.label} for ${damages} hp.
					fatalHitFlavour: $$> ^yThe ^rfireball^y explosion blast ${target.label} for ${damages} hp.
					targetChance: 0.5
					targetCount: 3
			
		[else]
			[fortune]
				- $> The ^rfireball^ misses ${defender.label}.
				- $> ${defender.label//uc1} evades the ^rfireball^:.
				- $> ${defender.label//uc1} avoids the ^rfireball^:.
	
	
	
	[scene deadly-push]
		[set $local.attackScore] $= ( ( max $attacker.actual.stats.strength ( $attacker.actual.stats.fighting - 3 ) ) + $battle.deadlyPush.bonus ) + ( 2 D 6 )
		[set $local.defenseScore] $= $defender.actual.stats.strength + ( 2 D 6 )
		
		#[message] $> Attacker ${attacker.label} offensiveness: ${attacker.adhoc.battle.offensiveness}
		[if $attacker.adhoc.battle.offensiveness > 0]
			[set $local.attackScore] $= $local.attackScore + 2
			#[message] Offensive: bonus!
		[elseif $attacker.adhoc.battle.offensiveness < 0]
			[set $local.attackScore] $= $local.attackScore - 3
			#[message] Defensive: malus!
		
		#[message] $> Defender ${defender.label} offensiveness: ${defender.adhoc.battle.offensiveness}
		[if $defender.adhoc.battle.offensiveness > 0]
			[set $local.defenseScore] $= $local.defenseScore - 3
			#[message] Offensive: malus!
		[elseif $defender.adhoc.battle.offensiveness < 0]
			[set $local.defenseScore] $= $local.defenseScore + 2
			#[message] Defensive: bonus!
		
		[if $local.attackScore > $local.defenseScore]
			[set $defender.status.hp] 0
			[apply-to $local.flavour] $battle.deadlyPush.flavour
			[message] $local.flavour
		
		
	
	
